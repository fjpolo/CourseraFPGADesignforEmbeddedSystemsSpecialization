
HelloWorld.elf:     file format elf32-littlenios2
HelloWorld.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00104180

Program Header:
    LOAD off    0x00001000 vaddr 0x00104000 paddr 0x00104000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x00104020 paddr 0x00104020 align 2**12
         filesz 0x00002014 memsz 0x00002014 flags r-x
    LOAD off    0x00003034 vaddr 0x00106034 paddr 0x0010627c align 2**12
         filesz 0x00000248 memsz 0x00000248 flags rw-
    LOAD off    0x000034c4 vaddr 0x001064c4 paddr 0x001064c4 align 2**12
         filesz 0x00000000 memsz 0x00000118 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  00104000  00104000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000160  00104020  00104020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         00001dac  00104180  00104180  00001180  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00000108  00105f2c  00105f2c  00002f2c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00000248  00106034  0010627c  00003034  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          00000118  001064c4  001064c4  000034c4  2**2
                  ALLOC, SMALL_DATA
  6 .onchip_flash_data 00000000  00080000  00080000  0000327c  2**0
                  CONTENTS
  7 .onchip_ram   00000000  001065dc  001065dc  0000327c  2**0
                  CONTENTS
  8 .comment      00000023  00000000  00000000  0000327c  2**0
                  CONTENTS, READONLY
  9 .debug_aranges 00000520  00000000  00000000  000032a0  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   00007323  00000000  00000000  000037c0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 00002651  00000000  00000000  0000aae3  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   00002ac6  00000000  00000000  0000d134  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  00000968  00000000  00000000  0000fbfc  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    000021d8  00000000  00000000  00010564  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    00002d8c  00000000  00000000  0001273c  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_alt_sim_info 00000040  00000000  00000000  000154c8  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_ranges 00000318  00000000  00000000  00015508  2**3
                  CONTENTS, READONLY, DEBUGGING
 18 .thread_model 00000003  00000000  00000000  00017351  2**0
                  CONTENTS, READONLY
 19 .cpu          00000004  00000000  00000000  00017354  2**0
                  CONTENTS, READONLY
 20 .qsys         00000001  00000000  00000000  00017358  2**0
                  CONTENTS, READONLY
 21 .simulation_enabled 00000001  00000000  00000000  00017359  2**0
                  CONTENTS, READONLY
 22 .sysid_hash   00000004  00000000  00000000  0001735a  2**0
                  CONTENTS, READONLY
 23 .sysid_base   00000004  00000000  00000000  0001735e  2**0
                  CONTENTS, READONLY
 24 .sysid_time   00000004  00000000  00000000  00017362  2**0
                  CONTENTS, READONLY
 25 .stderr_dev   00000009  00000000  00000000  00017366  2**0
                  CONTENTS, READONLY
 26 .stdin_dev    00000009  00000000  00000000  0001736f  2**0
                  CONTENTS, READONLY
 27 .stdout_dev   00000009  00000000  00000000  00017378  2**0
                  CONTENTS, READONLY
 28 .sopc_system_name 00000008  00000000  00000000  00017381  2**0
                  CONTENTS, READONLY
 29 .quartus_project_dir 0000008b  00000000  00000000  00017389  2**0
                  CONTENTS, READONLY
 30 .sopcinfo     00083ed8  00000000  00000000  00017414  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00104000 l    d  .entry	00000000 .entry
00104020 l    d  .exceptions	00000000 .exceptions
00104180 l    d  .text	00000000 .text
00105f2c l    d  .rodata	00000000 .rodata
00106034 l    d  .rwdata	00000000 .rwdata
001064c4 l    d  .bss	00000000 .bss
00080000 l    d  .onchip_flash_data	00000000 .onchip_flash_data
001065dc l    d  .onchip_ram	00000000 .onchip_ram
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../HelloWorld_bsp//obj/HAL/src/crt0.o
001041b8 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_instruction_exception_entry.c
00000000 l    df *ABS*	00000000 hello_world_small.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 printf.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 vfprintf.c
00104758 l     F .text	0000006c print_repeat
00000000 l    df *ABS*	00000000 fvwrite_small_dev.c
00000000 l    df *ABS*	00000000 impure.c
00106034 l     O .rwdata	000000e0 impure_data
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 lib2-mul.c
00000000 l    df *ABS*	00000000 alt_load.c
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_write.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
00106214 l     O .rwdata	0000003c adc0
00106114 l     O .rwdata	00000100 onchip_flash
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_spi.c
00000000 l    df *ABS*	00000000 altera_modular_adc.c
001052b4 l     F .text	00000058 alt_adc_irq
00000000 l    df *ABS*	00000000 altera_onchip_flash.c
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_dcache_flush.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_flash_dev.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 memcpy.c
001064d8 g     O .bss	00000004 alt_instruction_exception_handler
00080000 g       *ABS*	00000000 __alt_mem_onchip_flash_data
001051c4 g     F .text	00000020 adc_stop
00104f24 g     F .text	0000002c alt_main
001046a8 g     F .text	00000080 _puts_r
001064dc g     O .bss	00000100 alt_irq
0010627c g       *ABS*	00000000 __flash_rwdata_start
0010465c g     F .text	0000004c printf
00106258 g     O .rwdata	00000004 jtag_uart
00105e58 g     F .text	00000008 altera_nios2_gen2_irq_init
00104000 g     F .entry	0000000c __reset
00105288 g     F .text	00000018 adc_interrupt_disable
00104020 g       *ABS*	00000000 __flash_exceptions_start
001064c4 g     O .bss	00000004 errno
00105158 g     F .text	00000064 altera_modular_adc_init
001064cc g     O .bss	00000004 alt_argv
0010e250 g       *ABS*	00000000 _gp
00104f50 g     F .text	00000004 usleep
0010598c g     F .text	0000005c alt_onchip_flash_poll_for_status_write_passed
00105c88 g     F .text	00000074 alt_find_dev
00105f04 g     F .text	00000028 memcpy
0010520c g     F .text	00000014 adc_set_mode_run_continuously
00104728 g     F .text	00000014 puts
00105e60 g     F .text	00000074 alt_exception_cause_generated_bad_addr
00104620 g     F .text	0000003c _printf_r
00104564 g     F .text	00000064 .hidden __udivsi3
00105844 g     F .text	0000005c alt_onchip_flash_poll_for_status_erase_passed
00106264 g     O .rwdata	00000008 altera_onchip_flash_list
0010625c g     O .rwdata	00000008 altera_modular_adc_list
00105c14 g     F .text	00000004 alt_dcache_flush
001058a0 g     F .text	000000ec alt_onchip_flash_erase_block
00106250 g     O .rwdata	00000004 _global_impure_ptr
001065dc g       *ABS*	00000000 __bss_end
00105df0 g     F .text	00000068 alt_iic_isr_register
00105370 g     F .text	00000014 adc_wait_for_interrupt
00105dd8 g     F .text	00000018 alt_ic_irq_enabled
001064d4 g     O .bss	00000004 alt_irq_active
001040fc g     F .exceptions	00000060 alt_irq_handler
001051f4 g     F .text	00000018 adc_set_mode_run_once
00105c18 g     F .text	00000004 alt_dcache_flush_all
0010627c g       *ABS*	00000000 __ram_rwdata_end
00104f54 g     F .text	00000060 write
00106034 g       *ABS*	00000000 __ram_rodata_end
001051e4 g     F .text	00000010 adc_start
001045c8 g     F .text	00000058 .hidden __umodsi3
001065dc g       *ABS*	00000000 end
0010415c g     F .exceptions	00000024 alt_instruction_exception_entry
00108000 g       *ABS*	00000000 __alt_stack_pointer
00105004 g     F .text	00000034 altera_avalon_jtag_uart_write
001047c4 g     F .text	0000052c ___vfprintf_internal_r
001053f4 g     F .text	00000044 alt_onchip_flash_get_info
00104180 g     F .text	0000003c _start
00105038 g     F .text	000000e8 alt_avalon_spi_command
00104fd4 g     F .text	00000030 alt_sys_init
00104e1c g     F .text	00000028 .hidden __mulsi3
00106034 g       *ABS*	00000000 __ram_rwdata_start
00105f2c g       *ABS*	00000000 __ram_rodata_start
00105b9c g     F .text	00000078 alt_busy_sleep
00105ed4 g     F .text	00000030 memcmp
001065dc g       *ABS*	00000000 __alt_stack_base
00105274 g     F .text	00000014 adc_interrupt_enable
00105384 g     F .text	00000070 alt_onchip_flash_read
00105c1c g     F .text	0000006c alt_dev_llist_insert
00106270 g     O .rwdata	00000008 alt_flash_dev_list
00104d0c g     F .text	000000b8 __sfvwrite_small_dev
001064c4 g       *ABS*	00000000 __bss_start
0010425c g     F .text	00000210 main
001064c8 g     O .bss	00000004 alt_envp
00105120 g     F .text	00000038 alt_adc_word_read
0010626c g     O .rwdata	00000004 alt_errno
001057f0 g     F .text	00000054 alt_onchip_flash_poll_for_status_to_go_idle
0010446c g     F .text	00000084 .hidden __divsi3
001055bc g     F .text	00000234 altera_onchip_flash_init
00105f2c g       *ABS*	00000000 __flash_rodata_start
00104fb4 g     F .text	00000020 alt_irq_init
00104dc4 g     F .text	00000058 _write_r
00106254 g     O .rwdata	00000004 _impure_ptr
001064d0 g     O .bss	00000004 alt_argc
00104020 g       .exceptions	00000000 alt_irq_entry
001059e8 g     F .text	000001b4 alt_onchip_flash_write_block
00104020 g       *ABS*	00000000 __ram_exceptions_start
00105d64 g     F .text	00000004 alt_ic_isr_register
0010627c g       *ABS*	00000000 _edata
00105438 g     F .text	00000184 alt_onchip_flash_write
001065dc g       *ABS*	00000000 _end
00105cfc g     F .text	00000050 alt_flash_open_dev
00105360 g     F .text	00000010 adc_interrupt_asserted
00104180 g       *ABS*	00000000 __ram_exceptions_end
00105da0 g     F .text	00000038 alt_ic_irq_disable
001052a0 g     F .text	00000014 adc_clear_interrupt_status
00105d4c g     F .text	00000014 alt_flash_close_dev
001044f0 g     F .text	00000074 .hidden __modsi3
00108000 g       *ABS*	00000000 __alt_data_end
00104020 g     F .exceptions	00000000 alt_exception
00104000 g       *ABS*	00000000 __alt_mem_onchip_ram
001041bc g     F .text	000000a0 init_LIS3DH
001051bc g     F .text	00000008 altera_modular_adc_open
0010400c g       .entry	00000000 _exit
0010473c g     F .text	0000001c strlen
00105220 g     F .text	00000054 adc_recalibrate
00105d60 g     F .text	00000004 alt_icache_flush_all
00106278 g     O .rwdata	00000004 alt_priority_mask
00105d68 g     F .text	00000038 alt_ic_irq_enable
00104cf0 g     F .text	0000001c __vfprintf_internal
00104e44 g     F .text	000000e0 alt_load
0010530c g     F .text	00000054 alt_adc_register_callback



Disassembly of section .entry:

00104000 <__reset>:
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
  104000:	00400434 	movhi	at,16
    ori r1, r1, %lo(_start)
  104004:	08506014 	ori	at,at,16768
    jmp r1
  104008:	0800683a 	jmp	at

0010400c <_exit>:
	...

Disassembly of section .exceptions:

00104020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
  104020:	deffed04 	addi	sp,sp,-76
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
  104024:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
  104028:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
  10402c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
  104030:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
  104034:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
  104038:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
  10403c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
  104040:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
  104044:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
  104048:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
  10404c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
  104050:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
  104054:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
  104058:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
  10405c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
  104060:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
  104064:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
  104068:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
  10406c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
  104070:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
  104074:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
  104078:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
  10407c:	10000326 	beq	r2,zero,10408c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
  104080:	20000226 	beq	r4,zero,10408c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
  104084:	01040fc0 	call	1040fc <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
  104088:	00000706 	br	1040a8 <alt_exception+0x88>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw ea, 72(sp) /* EA is PC+4 so will skip over instruction causing exception */
  10408c:	df401215 	stw	ea,72(sp)
.Lunknown_16bit:
        addi.n r4, r4, 2 /* Need PC+2 to skip over instruction causing exception */
        stw r4, 72(sp)

#else /* CDX is not Enabled and all instructions are 32bits */
        ldw r2, -4(ea) /* Instruction value that caused exception */
  104090:	e8bfff17 	ldw	r2,-4(ea)
         * debugger is present) or go into an infinite loop since the
         * handling behavior is undefined; in that case we will not return here.
         */

        /* Load exception-causing address as first argument (r4) */
        addi   r4, ea, -4
  104094:	e93fff04 	addi	r4,ea,-4

        /* Call the instruction-exception entry */
        call   alt_instruction_exception_entry
  104098:	010415c0 	call	10415c <alt_instruction_exception_entry>
         * instruction
         *
         * Return code was 0: Skip. The instruction after the exception is
         * already stored in 72(sp).
         */
        bne   r2, r0, .Lexception_exit
  10409c:	1000021e 	bne	r2,zero,1040a8 <alt_exception+0x88>

        /*
         * Otherwise, modify 72(sp) to re-issue the instruction that caused the
         * exception.
         */
        addi  r15, ea, -4  /* instruction that caused exception */
  1040a0:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
  1040a4:	dbc01215 	stw	r15,72(sp)
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
  1040a8:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
  1040ac:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
  1040b0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
  1040b4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
  1040b8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
  1040bc:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
  1040c0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
  1040c4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
  1040c8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
  1040cc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
  1040d0:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
  1040d4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
  1040d8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
  1040dc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
  1040e0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
  1040e4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
  1040e8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
  1040ec:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
  1040f0:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
  1040f4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
  1040f8:	ef80083a 	eret

001040fc <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
  1040fc:	defffe04 	addi	sp,sp,-8
  104100:	dfc00115 	stw	ra,4(sp)
  104104:	dc000015 	stw	r16,0(sp)
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
  104108:	0009313a 	rdctl	r4,ipending
    do
    {
      if (active & mask)
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
  10410c:	04000434 	movhi	r16,16
  104110:	84193704 	addi	r16,r16,25820

  active = alt_irq_pending ();

  do
  {
    i = 0;
  104114:	0005883a 	mov	r2,zero
    mask = 1;
  104118:	00c00044 	movi	r3,1
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
  10411c:	20ca703a 	and	r5,r4,r3
  104120:	28000b26 	beq	r5,zero,104150 <alt_irq_handler+0x54>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
  104124:	100490fa 	slli	r2,r2,3
  104128:	8085883a 	add	r2,r16,r2
  10412c:	10c00017 	ldw	r3,0(r2)
  104130:	11000117 	ldw	r4,4(r2)
  104134:	183ee83a 	callr	r3
  104138:	0009313a 	rdctl	r4,ipending

    } while (1);

    active = alt_irq_pending ();
    
  } while (active);
  10413c:	203ff51e 	bne	r4,zero,104114 <_gp+0xffff5ec4>
  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
}
  104140:	dfc00117 	ldw	ra,4(sp)
  104144:	dc000017 	ldw	r16,0(sp)
  104148:	dec00204 	addi	sp,sp,8
  10414c:	f800283a 	ret
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
      }
      mask <<= 1;
  104150:	18c7883a 	add	r3,r3,r3
      i++;
  104154:	10800044 	addi	r2,r2,1

    } while (1);
  104158:	003ff006 	br	10411c <_gp+0xffff5ecc>

0010415c <alt_instruction_exception_entry>:
#else
  cause = NIOS2_EXCEPTION_CAUSE_NOT_PRESENT;
  badaddr = 0;
#endif /* NIOS2_HAS_EXTRA_EXCEPTION_INFO */

  if(alt_instruction_exception_handler) {
  10415c:	d0a0a217 	ldw	r2,-32120(gp)
  104160:	10000426 	beq	r2,zero,104174 <alt_instruction_exception_entry+0x18>
     * Call handler. Its return value indicates whether the exception-causing
     * instruction should be re-issued. The code that called us,
     * alt_eceptions_entry.S, will look at this value and adjust the ea
     * register as necessary
     */
    return alt_instruction_exception_handler(cause, exception_pc, badaddr);
  104164:	200b883a 	mov	r5,r4
  104168:	000d883a 	mov	r6,zero
  10416c:	013fffc4 	movi	r4,-1
  104170:	1000683a 	jmp	r2
   *    (a peripheral which negates its interrupt output before its
   *    interrupt handler has been executed will cause spurious interrupts)
   */
  else {
#ifdef NIOS2_HAS_DEBUG_STUB
    NIOS2_BREAK();
  104174:	003da03a 	break	0
#endif /* NIOS2_HAS_DEBUG_STUB */
  }

  /* We should not get here. Remove compiler warning. */
  return NIOS2_EXCEPTION_RETURN_REISSUE_INST;
}
  104178:	0005883a 	mov	r2,zero
  10417c:	f800283a 	ret

Disassembly of section .text:

00104180 <_start>:

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
  104180:	06c00434 	movhi	sp,16
    ori sp, sp, %lo(__alt_stack_pointer)
  104184:	dee00014 	ori	sp,sp,32768
    movhi gp, %hi(_gp)
  104188:	06800434 	movhi	gp,16
    ori gp, gp, %lo(_gp)
  10418c:	d6b89414 	ori	gp,gp,57936
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
  104190:	00800434 	movhi	r2,16
    ori r2, r2, %lo(__bss_start)
  104194:	10993114 	ori	r2,r2,25796

    movhi r3, %hi(__bss_end)
  104198:	00c00434 	movhi	r3,16
    ori r3, r3, %lo(__bss_end)
  10419c:	18d97714 	ori	r3,r3,26076

    beq r2, r3, 1f
  1041a0:	10c00326 	beq	r2,r3,1041b0 <_start+0x30>

0:
    stw zero, (r2)
  1041a4:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
  1041a8:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
  1041ac:	10fffd36 	bltu	r2,r3,1041a4 <_gp+0xffff5f54>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
  1041b0:	0104e440 	call	104e44 <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
  1041b4:	0104f240 	call	104f24 <alt_main>

001041b8 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
  1041b8:	003fff06 	br	1041b8 <_gp+0xffff5f68>

001041bc <init_LIS3DH>:
	}
	return 0;
}

void init_LIS3DH()
{
  1041bc:	defff804 	addi	sp,sp,-32
  1041c0:	dc000415 	stw	r16,16(sp)

	wdata[0]= 0x40 | 0x20;		// write multiple bytes with start address 0x20
	wdata[1]= 0x37;				// 25Hz mode, low power off, enable axis Z Y X
	wdata[2]= 0x00;				// all filters disabled

	alt_avalon_spi_command (SPI_LIS3DH_BASE, 0, 3, wdata, 0, rdata, 0);
  1041c4:	04000474 	movhi	r16,17
	}
	return 0;
}

void init_LIS3DH()
{
  1041c8:	dc800615 	stw	r18,24(sp)
  1041cc:	dc400515 	stw	r17,20(sp)

	wdata[0]= 0x40 | 0x20;		// write multiple bytes with start address 0x20
	wdata[1]= 0x37;				// 25Hz mode, low power off, enable axis Z Y X
	wdata[2]= 0x00;				// all filters disabled

	alt_avalon_spi_command (SPI_LIS3DH_BASE, 0, 3, wdata, 0, rdata, 0);
  1041d0:	84248804 	addi	r16,r16,-28128
  1041d4:	044000c4 	movi	r17,3
  1041d8:	dc8003c4 	addi	r18,sp,15
void init_LIS3DH()
{
	unsigned char wdata[3];
	unsigned char rdata[1];

	wdata[0]= 0x40 | 0x20;		// write multiple bytes with start address 0x20
  1041dc:	00801804 	movi	r2,96
  1041e0:	d8800305 	stb	r2,12(sp)
	wdata[1]= 0x37;				// 25Hz mode, low power off, enable axis Z Y X
	wdata[2]= 0x00;				// all filters disabled

	alt_avalon_spi_command (SPI_LIS3DH_BASE, 0, 3, wdata, 0, rdata, 0);
  1041e4:	d9c00304 	addi	r7,sp,12
  1041e8:	880d883a 	mov	r6,r17
  1041ec:	8009883a 	mov	r4,r16
{
	unsigned char wdata[3];
	unsigned char rdata[1];

	wdata[0]= 0x40 | 0x20;		// write multiple bytes with start address 0x20
	wdata[1]= 0x37;				// 25Hz mode, low power off, enable axis Z Y X
  1041f0:	00800dc4 	movi	r2,55
	wdata[2]= 0x00;				// all filters disabled

	alt_avalon_spi_command (SPI_LIS3DH_BASE, 0, 3, wdata, 0, rdata, 0);
  1041f4:	d8000215 	stw	zero,8(sp)
  1041f8:	dc800115 	stw	r18,4(sp)
  1041fc:	d8000015 	stw	zero,0(sp)
  104200:	000b883a 	mov	r5,zero
	}
	return 0;
}

void init_LIS3DH()
{
  104204:	dfc00715 	stw	ra,28(sp)
	unsigned char wdata[3];
	unsigned char rdata[1];

	wdata[0]= 0x40 | 0x20;		// write multiple bytes with start address 0x20
	wdata[1]= 0x37;				// 25Hz mode, low power off, enable axis Z Y X
  104208:	d8800345 	stb	r2,13(sp)
	wdata[2]= 0x00;				// all filters disabled
  10420c:	d8000385 	stb	zero,14(sp)

	alt_avalon_spi_command (SPI_LIS3DH_BASE, 0, 3, wdata, 0, rdata, 0);
  104210:	01050380 	call	105038 <alt_avalon_spi_command>

	wdata[0]= 0x40 | 0x22;		// write multiple bytes with start address 0x22
  104214:	00801884 	movi	r2,98
	wdata[1]= 0x00;				// all interrupts disabled
	wdata[2]= 0x00;				// continuous update, little endian, 2g full scale, high resolution disabled, self test disabled, 4 wire SPI

	alt_avalon_spi_command (SPI_LIS3DH_BASE, 0, 3, wdata, 0, rdata, 0);
  104218:	d8000215 	stw	zero,8(sp)
  10421c:	dc800115 	stw	r18,4(sp)
  104220:	d8000015 	stw	zero,0(sp)
  104224:	d9c00304 	addi	r7,sp,12
  104228:	880d883a 	mov	r6,r17
  10422c:	000b883a 	mov	r5,zero
  104230:	8009883a 	mov	r4,r16
	wdata[1]= 0x37;				// 25Hz mode, low power off, enable axis Z Y X
	wdata[2]= 0x00;				// all filters disabled

	alt_avalon_spi_command (SPI_LIS3DH_BASE, 0, 3, wdata, 0, rdata, 0);

	wdata[0]= 0x40 | 0x22;		// write multiple bytes with start address 0x22
  104234:	d8800305 	stb	r2,12(sp)
	wdata[1]= 0x00;				// all interrupts disabled
  104238:	d8000345 	stb	zero,13(sp)
	wdata[2]= 0x00;				// continuous update, little endian, 2g full scale, high resolution disabled, self test disabled, 4 wire SPI
  10423c:	d8000385 	stb	zero,14(sp)

	alt_avalon_spi_command (SPI_LIS3DH_BASE, 0, 3, wdata, 0, rdata, 0);
  104240:	01050380 	call	105038 <alt_avalon_spi_command>
}
  104244:	dfc00717 	ldw	ra,28(sp)
  104248:	dc800617 	ldw	r18,24(sp)
  10424c:	dc400517 	ldw	r17,20(sp)
  104250:	dc000417 	ldw	r16,16(sp)
  104254:	dec00804 	addi	sp,sp,32
  104258:	f800283a 	ret

0010425c <main>:
	alt_8 y_value_2 	= 0;
	alt_8 y_value_3 	= 0;
	alt_8 y_value_4 	= 0;
	alt_8 y_value_5 	= 0;

	printf("Nios Lab with MAX1000!\n");
  10425c:	01000434 	movhi	r4,16
#include "altera_avalon_spi.h"

void init_LIS3DH();

int main()
{
  104260:	defff104 	addi	sp,sp,-60
	alt_8 y_value_2 	= 0;
	alt_8 y_value_3 	= 0;
	alt_8 y_value_4 	= 0;
	alt_8 y_value_5 	= 0;

	printf("Nios Lab with MAX1000!\n");
  104264:	2117cb04 	addi	r4,r4,24364
#include "altera_avalon_spi.h"

void init_LIS3DH();

int main()
{
  104268:	dfc00e15 	stw	ra,56(sp)
  10426c:	df000d15 	stw	fp,52(sp)
  104270:	dd800b15 	stw	r22,44(sp)
  104274:	dd400a15 	stw	r21,40(sp)
  104278:	dd000915 	stw	r20,36(sp)
  10427c:	dcc00815 	stw	r19,32(sp)
  104280:	dc800715 	stw	r18,28(sp)
  104284:	dc400615 	stw	r17,24(sp)
  104288:	ddc00c15 	stw	r23,48(sp)
  10428c:	dc000515 	stw	r16,20(sp)
	alt_8 y_value_2 	= 0;
	alt_8 y_value_3 	= 0;
	alt_8 y_value_4 	= 0;
	alt_8 y_value_5 	= 0;

	printf("Nios Lab with MAX1000!\n");
  104290:	01047280 	call	104728 <puts>
	printf("---------------------------------------------------------------------------------\n");
  104294:	01000434 	movhi	r4,16
  104298:	2117d104 	addi	r4,r4,24388
  10429c:	01047280 	call	104728 <puts>
	printf("DEMO:\n");
  1042a0:	01000434 	movhi	r4,16
  1042a4:	2117e604 	addi	r4,r4,24472
  1042a8:	01047280 	call	104728 <puts>
	printf("Read y-axis value of the accelerometer and have the LEDs react to received values\n");
  1042ac:	01000434 	movhi	r4,16
  1042b0:	2117e804 	addi	r4,r4,24480
  1042b4:	01047280 	call	104728 <puts>
	printf("---------------------------------------------------------------------------------\n");
  1042b8:	01000434 	movhi	r4,16
  1042bc:	2117d104 	addi	r4,r4,24388
  1042c0:	01047280 	call	104728 <puts>
	usleep(2000000);				// wait 2s
  1042c4:	010007f4 	movhi	r4,31
  1042c8:	21212004 	addi	r4,r4,-31616
  1042cc:	0104f500 	call	104f50 <usleep>

	init_LIS3DH();				// initiate LIS3DH
  1042d0:	01041bc0 	call	1041bc <init_LIS3DH>
	wdata[0]=0xC0 | 0x2A;       // read y-register and increment
  1042d4:	00bffa84 	movi	r2,-22

		// save current value for next comparison
		prev_y_value = y_value;

		// set LED
		IOWR_ALTERA_AVALON_PIO_DATA(PIO_LEDS_BASE, led_out);
  1042d8:	07000474 	movhi	fp,17
	printf("Read y-axis value of the accelerometer and have the LEDs react to received values\n");
	printf("---------------------------------------------------------------------------------\n");
	usleep(2000000);				// wait 2s

	init_LIS3DH();				// initiate LIS3DH
	wdata[0]=0xC0 | 0x2A;       // read y-register and increment
  1042dc:	d8800385 	stb	r2,14(sp)
	alt_8 y_value   	= 0;			// create buffer for filtering
	alt_8 prev_y_value 	= 0;
	alt_8 y_value_1 	= 0;
	alt_8 y_value_2 	= 0;
	alt_8 y_value_3 	= 0;
	alt_8 y_value_4 	= 0;
  1042e0:	0007883a 	mov	r3,zero

	alt_8 y_value   	= 0;			// create buffer for filtering
	alt_8 prev_y_value 	= 0;
	alt_8 y_value_1 	= 0;
	alt_8 y_value_2 	= 0;
	alt_8 y_value_3 	= 0;
  1042e4:	002d883a 	mov	r22,zero
	unsigned char led_out = 0x18;

	alt_8 y_value   	= 0;			// create buffer for filtering
	alt_8 prev_y_value 	= 0;
	alt_8 y_value_1 	= 0;
	alt_8 y_value_2 	= 0;
  1042e8:	002b883a 	mov	r21,zero
	unsigned char rdata[2];
	unsigned char led_out = 0x18;

	alt_8 y_value   	= 0;			// create buffer for filtering
	alt_8 prev_y_value 	= 0;
	alt_8 y_value_1 	= 0;
  1042ec:	0029883a 	mov	r20,zero
	unsigned char wdata[1];
	unsigned char rdata[2];
	unsigned char led_out = 0x18;

	alt_8 y_value   	= 0;			// create buffer for filtering
	alt_8 prev_y_value 	= 0;
  1042f0:	0027883a 	mov	r19,zero

int main()
{
	unsigned char wdata[1];
	unsigned char rdata[2];
	unsigned char led_out = 0x18;
  1042f4:	04400604 	movi	r17,24


		// determine LED setting according to y-axis value
		if (y_value > -4 && y_value < 4)
			led_out = 0x18;
		if (y_value >= 4 && y_value < 8)
  1042f8:	048000c4 	movi	r18,3

		// save current value for next comparison
		prev_y_value = y_value;

		// set LED
		IOWR_ALTERA_AVALON_PIO_DATA(PIO_LEDS_BASE, led_out);
  1042fc:	e7249404 	addi	fp,fp,-28080
	wdata[0]=0xC0 | 0x2A;       // read y-register and increment

	while (1)
	{
		// read y-axis data from gyro
		alt_avalon_spi_command (SPI_LIS3DH_BASE, 0, 1, wdata, 2, rdata, 0);
  104300:	d8800304 	addi	r2,sp,12
  104304:	d8800115 	stw	r2,4(sp)
  104308:	01000474 	movhi	r4,17
  10430c:	00800084 	movi	r2,2
  104310:	d9c00384 	addi	r7,sp,14
  104314:	01800044 	movi	r6,1
  104318:	000b883a 	mov	r5,zero
  10431c:	21248804 	addi	r4,r4,-28128
  104320:	d8000215 	stw	zero,8(sp)
  104324:	d8800015 	stw	r2,0(sp)
  104328:	d8c00415 	stw	r3,16(sp)
  10432c:	01050380 	call	105038 <alt_avalon_spi_command>
		// calculate average
		y_value_5 = y_value_4;
		y_value_4 = y_value_3;
		y_value_3 = y_value_2;
		y_value_2 = y_value_1;
		y_value_1 = rdata[1];
  104330:	ddc00343 	ldbu	r23,13(sp)

		y_value = (y_value_1 + y_value_2 + y_value_3 + y_value_4 + y_value_5) / 5;
  104334:	a0803fcc 	andi	r2,r20,255
  104338:	1080201c 	xori	r2,r2,128
  10433c:	b9003fcc 	andi	r4,r23,255
  104340:	2100201c 	xori	r4,r4,128
  104344:	10bfe004 	addi	r2,r2,-128
  104348:	213fe004 	addi	r4,r4,-128
  10434c:	2089883a 	add	r4,r4,r2
  104350:	a8803fcc 	andi	r2,r21,255
  104354:	1080201c 	xori	r2,r2,128
  104358:	d8c00417 	ldw	r3,16(sp)
  10435c:	10bfe004 	addi	r2,r2,-128
  104360:	2089883a 	add	r4,r4,r2
  104364:	b0803fcc 	andi	r2,r22,255
  104368:	1080201c 	xori	r2,r2,128
  10436c:	18c03fcc 	andi	r3,r3,255
  104370:	10bfe004 	addi	r2,r2,-128
  104374:	18c0201c 	xori	r3,r3,128
  104378:	18ffe004 	addi	r3,r3,-128
  10437c:	2089883a 	add	r4,r4,r2
  104380:	20c9883a 	add	r4,r4,r3
  104384:	01400144 	movi	r5,5
  104388:	010446c0 	call	10446c <__divsi3>
  10438c:	1021883a 	mov	r16,r2


		// determine LED setting according to y-axis value
		if (y_value > -4 && y_value < 4)
  104390:	108000c4 	addi	r2,r2,3
  104394:	10803fcc 	andi	r2,r2,255
  104398:	00c00184 	movi	r3,6
  10439c:	18800136 	bltu	r3,r2,1043a4 <main+0x148>
			led_out = 0x18;
  1043a0:	04400604 	movi	r17,24
		if (y_value >= 4 && y_value < 8)
  1043a4:	80bfff04 	addi	r2,r16,-4
  1043a8:	10803fcc 	andi	r2,r2,255
  1043ac:	90800136 	bltu	r18,r2,1043b4 <main+0x158>
			led_out = 0x08;
  1043b0:	04400204 	movi	r17,8
		if (y_value >= 8 && y_value < 12)
  1043b4:	80bffe04 	addi	r2,r16,-8
  1043b8:	10803fcc 	andi	r2,r2,255
  1043bc:	90800136 	bltu	r18,r2,1043c4 <main+0x168>
			led_out = 0x04;
  1043c0:	04400104 	movi	r17,4
		if (y_value >= 12 && y_value < 16)
  1043c4:	80bffd04 	addi	r2,r16,-12
  1043c8:	10803fcc 	andi	r2,r2,255
  1043cc:	90800136 	bltu	r18,r2,1043d4 <main+0x178>
			led_out = 0x02;
  1043d0:	04400084 	movi	r17,2
		if (y_value >= 16)
  1043d4:	008003c4 	movi	r2,15
  1043d8:	1400010e 	bge	r2,r16,1043e0 <main+0x184>
			led_out = 0x01;
  1043dc:	04400044 	movi	r17,1
		if (y_value > -8 && y_value <= -4)
  1043e0:	808001c4 	addi	r2,r16,7
  1043e4:	10803fcc 	andi	r2,r2,255
  1043e8:	90800136 	bltu	r18,r2,1043f0 <main+0x194>
			led_out = 0x10;
  1043ec:	04400404 	movi	r17,16
		if (y_value > -12 && y_value <= -8)
  1043f0:	808002c4 	addi	r2,r16,11
  1043f4:	10803fcc 	andi	r2,r2,255
  1043f8:	90800136 	bltu	r18,r2,104400 <main+0x1a4>
			led_out = 0x20;
  1043fc:	04400804 	movi	r17,32
		if (y_value > -16 && y_value <= -12)
  104400:	808003c4 	addi	r2,r16,15
  104404:	10803fcc 	andi	r2,r2,255
  104408:	90800136 	bltu	r18,r2,104410 <main+0x1b4>
			led_out = 0x40;
  10440c:	04401004 	movi	r17,64
		if (y_value <= -16)
  104410:	00bffc44 	movi	r2,-15
  104414:	8080010e 	bge	r16,r2,10441c <main+0x1c0>
			led_out = 0x80;
  104418:	047fe004 	movi	r17,-128

		//Send y-axis values to Nios II Console if value has changed
		if (y_value != prev_y_value)
  10441c:	9cc03fcc 	andi	r19,r19,255
  104420:	81403fcc 	andi	r5,r16,255
  104424:	9cc0201c 	xori	r19,r19,128
  104428:	2940201c 	xori	r5,r5,128
  10442c:	9cffe004 	addi	r19,r19,-128
  104430:	297fe004 	addi	r5,r5,-128
  104434:	99400326 	beq	r19,r5,104444 <main+0x1e8>
			printf("Y-AXIS: %d\n",y_value);
  104438:	01000434 	movhi	r4,16
  10443c:	2117fd04 	addi	r4,r4,24564
  104440:	010465c0 	call	10465c <printf>

		// save current value for next comparison
		prev_y_value = y_value;

		// set LED
		IOWR_ALTERA_AVALON_PIO_DATA(PIO_LEDS_BASE, led_out);
  104444:	88803fcc 	andi	r2,r17,255
  104448:	e0800035 	stwio	r2,0(fp)

		// wait 10ms
		usleep(10000);
  10444c:	0109c404 	movi	r4,10000
  104450:	0104f500 	call	104f50 <usleep>
		alt_avalon_spi_command (SPI_LIS3DH_BASE, 0, 1, wdata, 2, rdata, 0);


		// calculate average
		y_value_5 = y_value_4;
		y_value_4 = y_value_3;
  104454:	b007883a 	mov	r3,r22
		y_value_3 = y_value_2;
		y_value_2 = y_value_1;
		y_value_1 = rdata[1];

		y_value = (y_value_1 + y_value_2 + y_value_3 + y_value_4 + y_value_5) / 5;
  104458:	8027883a 	mov	r19,r16


		// calculate average
		y_value_5 = y_value_4;
		y_value_4 = y_value_3;
		y_value_3 = y_value_2;
  10445c:	a82d883a 	mov	r22,r21
		y_value_2 = y_value_1;
  104460:	a02b883a 	mov	r21,r20
		y_value_1 = rdata[1];
  104464:	b829883a 	mov	r20,r23
		// set LED
		IOWR_ALTERA_AVALON_PIO_DATA(PIO_LEDS_BASE, led_out);

		// wait 10ms
		usleep(10000);
	}
  104468:	003fa506 	br	104300 <_gp+0xffff60b0>

0010446c <__divsi3>:
  10446c:	20001b16 	blt	r4,zero,1044dc <__divsi3+0x70>
  104470:	000f883a 	mov	r7,zero
  104474:	28001616 	blt	r5,zero,1044d0 <__divsi3+0x64>
  104478:	200d883a 	mov	r6,r4
  10447c:	29001a2e 	bgeu	r5,r4,1044e8 <__divsi3+0x7c>
  104480:	00800804 	movi	r2,32
  104484:	00c00044 	movi	r3,1
  104488:	00000106 	br	104490 <__divsi3+0x24>
  10448c:	10000d26 	beq	r2,zero,1044c4 <__divsi3+0x58>
  104490:	294b883a 	add	r5,r5,r5
  104494:	10bfffc4 	addi	r2,r2,-1
  104498:	18c7883a 	add	r3,r3,r3
  10449c:	293ffb36 	bltu	r5,r4,10448c <_gp+0xffff623c>
  1044a0:	0005883a 	mov	r2,zero
  1044a4:	18000726 	beq	r3,zero,1044c4 <__divsi3+0x58>
  1044a8:	0005883a 	mov	r2,zero
  1044ac:	31400236 	bltu	r6,r5,1044b8 <__divsi3+0x4c>
  1044b0:	314dc83a 	sub	r6,r6,r5
  1044b4:	10c4b03a 	or	r2,r2,r3
  1044b8:	1806d07a 	srli	r3,r3,1
  1044bc:	280ad07a 	srli	r5,r5,1
  1044c0:	183ffa1e 	bne	r3,zero,1044ac <_gp+0xffff625c>
  1044c4:	38000126 	beq	r7,zero,1044cc <__divsi3+0x60>
  1044c8:	0085c83a 	sub	r2,zero,r2
  1044cc:	f800283a 	ret
  1044d0:	014bc83a 	sub	r5,zero,r5
  1044d4:	39c0005c 	xori	r7,r7,1
  1044d8:	003fe706 	br	104478 <_gp+0xffff6228>
  1044dc:	0109c83a 	sub	r4,zero,r4
  1044e0:	01c00044 	movi	r7,1
  1044e4:	003fe306 	br	104474 <_gp+0xffff6224>
  1044e8:	00c00044 	movi	r3,1
  1044ec:	003fee06 	br	1044a8 <_gp+0xffff6258>

001044f0 <__modsi3>:
  1044f0:	20001716 	blt	r4,zero,104550 <__modsi3+0x60>
  1044f4:	000f883a 	mov	r7,zero
  1044f8:	2005883a 	mov	r2,r4
  1044fc:	28001216 	blt	r5,zero,104548 <__modsi3+0x58>
  104500:	2900162e 	bgeu	r5,r4,10455c <__modsi3+0x6c>
  104504:	01800804 	movi	r6,32
  104508:	00c00044 	movi	r3,1
  10450c:	00000106 	br	104514 <__modsi3+0x24>
  104510:	30000a26 	beq	r6,zero,10453c <__modsi3+0x4c>
  104514:	294b883a 	add	r5,r5,r5
  104518:	31bfffc4 	addi	r6,r6,-1
  10451c:	18c7883a 	add	r3,r3,r3
  104520:	293ffb36 	bltu	r5,r4,104510 <_gp+0xffff62c0>
  104524:	18000526 	beq	r3,zero,10453c <__modsi3+0x4c>
  104528:	1806d07a 	srli	r3,r3,1
  10452c:	11400136 	bltu	r2,r5,104534 <__modsi3+0x44>
  104530:	1145c83a 	sub	r2,r2,r5
  104534:	280ad07a 	srli	r5,r5,1
  104538:	183ffb1e 	bne	r3,zero,104528 <_gp+0xffff62d8>
  10453c:	38000126 	beq	r7,zero,104544 <__modsi3+0x54>
  104540:	0085c83a 	sub	r2,zero,r2
  104544:	f800283a 	ret
  104548:	014bc83a 	sub	r5,zero,r5
  10454c:	003fec06 	br	104500 <_gp+0xffff62b0>
  104550:	0109c83a 	sub	r4,zero,r4
  104554:	01c00044 	movi	r7,1
  104558:	003fe706 	br	1044f8 <_gp+0xffff62a8>
  10455c:	00c00044 	movi	r3,1
  104560:	003ff106 	br	104528 <_gp+0xffff62d8>

00104564 <__udivsi3>:
  104564:	200d883a 	mov	r6,r4
  104568:	2900152e 	bgeu	r5,r4,1045c0 <__udivsi3+0x5c>
  10456c:	28001416 	blt	r5,zero,1045c0 <__udivsi3+0x5c>
  104570:	00800804 	movi	r2,32
  104574:	00c00044 	movi	r3,1
  104578:	00000206 	br	104584 <__udivsi3+0x20>
  10457c:	10000e26 	beq	r2,zero,1045b8 <__udivsi3+0x54>
  104580:	28000516 	blt	r5,zero,104598 <__udivsi3+0x34>
  104584:	294b883a 	add	r5,r5,r5
  104588:	10bfffc4 	addi	r2,r2,-1
  10458c:	18c7883a 	add	r3,r3,r3
  104590:	293ffa36 	bltu	r5,r4,10457c <_gp+0xffff632c>
  104594:	18000826 	beq	r3,zero,1045b8 <__udivsi3+0x54>
  104598:	0005883a 	mov	r2,zero
  10459c:	31400236 	bltu	r6,r5,1045a8 <__udivsi3+0x44>
  1045a0:	314dc83a 	sub	r6,r6,r5
  1045a4:	10c4b03a 	or	r2,r2,r3
  1045a8:	1806d07a 	srli	r3,r3,1
  1045ac:	280ad07a 	srli	r5,r5,1
  1045b0:	183ffa1e 	bne	r3,zero,10459c <_gp+0xffff634c>
  1045b4:	f800283a 	ret
  1045b8:	0005883a 	mov	r2,zero
  1045bc:	f800283a 	ret
  1045c0:	00c00044 	movi	r3,1
  1045c4:	003ff406 	br	104598 <_gp+0xffff6348>

001045c8 <__umodsi3>:
  1045c8:	2005883a 	mov	r2,r4
  1045cc:	2900122e 	bgeu	r5,r4,104618 <__umodsi3+0x50>
  1045d0:	28001116 	blt	r5,zero,104618 <__umodsi3+0x50>
  1045d4:	01800804 	movi	r6,32
  1045d8:	00c00044 	movi	r3,1
  1045dc:	00000206 	br	1045e8 <__umodsi3+0x20>
  1045e0:	30000c26 	beq	r6,zero,104614 <__umodsi3+0x4c>
  1045e4:	28000516 	blt	r5,zero,1045fc <__umodsi3+0x34>
  1045e8:	294b883a 	add	r5,r5,r5
  1045ec:	31bfffc4 	addi	r6,r6,-1
  1045f0:	18c7883a 	add	r3,r3,r3
  1045f4:	293ffa36 	bltu	r5,r4,1045e0 <_gp+0xffff6390>
  1045f8:	18000626 	beq	r3,zero,104614 <__umodsi3+0x4c>
  1045fc:	1806d07a 	srli	r3,r3,1
  104600:	11400136 	bltu	r2,r5,104608 <__umodsi3+0x40>
  104604:	1145c83a 	sub	r2,r2,r5
  104608:	280ad07a 	srli	r5,r5,1
  10460c:	183ffb1e 	bne	r3,zero,1045fc <_gp+0xffff63ac>
  104610:	f800283a 	ret
  104614:	f800283a 	ret
  104618:	00c00044 	movi	r3,1
  10461c:	003ff706 	br	1045fc <_gp+0xffff63ac>

00104620 <_printf_r>:
  104620:	defffd04 	addi	sp,sp,-12
  104624:	dfc00015 	stw	ra,0(sp)
  104628:	d9800115 	stw	r6,4(sp)
  10462c:	d9c00215 	stw	r7,8(sp)
  104630:	20c00217 	ldw	r3,8(r4)
  104634:	01800434 	movhi	r6,16
  104638:	31934304 	addi	r6,r6,19724
  10463c:	19800115 	stw	r6,4(r3)
  104640:	280d883a 	mov	r6,r5
  104644:	21400217 	ldw	r5,8(r4)
  104648:	d9c00104 	addi	r7,sp,4
  10464c:	01047c40 	call	1047c4 <___vfprintf_internal_r>
  104650:	dfc00017 	ldw	ra,0(sp)
  104654:	dec00304 	addi	sp,sp,12
  104658:	f800283a 	ret

0010465c <printf>:
  10465c:	defffc04 	addi	sp,sp,-16
  104660:	dfc00015 	stw	ra,0(sp)
  104664:	d9400115 	stw	r5,4(sp)
  104668:	d9800215 	stw	r6,8(sp)
  10466c:	d9c00315 	stw	r7,12(sp)
  104670:	00800434 	movhi	r2,16
  104674:	10989504 	addi	r2,r2,25172
  104678:	10800017 	ldw	r2,0(r2)
  10467c:	01400434 	movhi	r5,16
  104680:	29534304 	addi	r5,r5,19724
  104684:	10c00217 	ldw	r3,8(r2)
  104688:	d9800104 	addi	r6,sp,4
  10468c:	19400115 	stw	r5,4(r3)
  104690:	200b883a 	mov	r5,r4
  104694:	11000217 	ldw	r4,8(r2)
  104698:	0104cf00 	call	104cf0 <__vfprintf_internal>
  10469c:	dfc00017 	ldw	ra,0(sp)
  1046a0:	dec00404 	addi	sp,sp,16
  1046a4:	f800283a 	ret

001046a8 <_puts_r>:
  1046a8:	defffd04 	addi	sp,sp,-12
  1046ac:	dc000015 	stw	r16,0(sp)
  1046b0:	2021883a 	mov	r16,r4
  1046b4:	2809883a 	mov	r4,r5
  1046b8:	dfc00215 	stw	ra,8(sp)
  1046bc:	dc400115 	stw	r17,4(sp)
  1046c0:	2823883a 	mov	r17,r5
  1046c4:	010473c0 	call	10473c <strlen>
  1046c8:	81400217 	ldw	r5,8(r16)
  1046cc:	01000434 	movhi	r4,16
  1046d0:	21134304 	addi	r4,r4,19724
  1046d4:	29000115 	stw	r4,4(r5)
  1046d8:	100f883a 	mov	r7,r2
  1046dc:	880d883a 	mov	r6,r17
  1046e0:	8009883a 	mov	r4,r16
  1046e4:	0104d0c0 	call	104d0c <__sfvwrite_small_dev>
  1046e8:	00ffffc4 	movi	r3,-1
  1046ec:	10c00926 	beq	r2,r3,104714 <_puts_r+0x6c>
  1046f0:	81400217 	ldw	r5,8(r16)
  1046f4:	01800434 	movhi	r6,16
  1046f8:	01c00044 	movi	r7,1
  1046fc:	28800117 	ldw	r2,4(r5)
  104700:	31980004 	addi	r6,r6,24576
  104704:	8009883a 	mov	r4,r16
  104708:	103ee83a 	callr	r2
  10470c:	10bfffe0 	cmpeqi	r2,r2,-1
  104710:	0085c83a 	sub	r2,zero,r2
  104714:	dfc00217 	ldw	ra,8(sp)
  104718:	dc400117 	ldw	r17,4(sp)
  10471c:	dc000017 	ldw	r16,0(sp)
  104720:	dec00304 	addi	sp,sp,12
  104724:	f800283a 	ret

00104728 <puts>:
  104728:	00800434 	movhi	r2,16
  10472c:	10989504 	addi	r2,r2,25172
  104730:	200b883a 	mov	r5,r4
  104734:	11000017 	ldw	r4,0(r2)
  104738:	01046a81 	jmpi	1046a8 <_puts_r>

0010473c <strlen>:
  10473c:	2005883a 	mov	r2,r4
  104740:	10c00007 	ldb	r3,0(r2)
  104744:	18000226 	beq	r3,zero,104750 <strlen+0x14>
  104748:	10800044 	addi	r2,r2,1
  10474c:	003ffc06 	br	104740 <_gp+0xffff64f0>
  104750:	1105c83a 	sub	r2,r2,r4
  104754:	f800283a 	ret

00104758 <print_repeat>:
  104758:	defffb04 	addi	sp,sp,-20
  10475c:	dc800315 	stw	r18,12(sp)
  104760:	dc400215 	stw	r17,8(sp)
  104764:	dc000115 	stw	r16,4(sp)
  104768:	dfc00415 	stw	ra,16(sp)
  10476c:	2025883a 	mov	r18,r4
  104770:	2823883a 	mov	r17,r5
  104774:	d9800005 	stb	r6,0(sp)
  104778:	3821883a 	mov	r16,r7
  10477c:	04000a0e 	bge	zero,r16,1047a8 <print_repeat+0x50>
  104780:	88800117 	ldw	r2,4(r17)
  104784:	01c00044 	movi	r7,1
  104788:	d80d883a 	mov	r6,sp
  10478c:	880b883a 	mov	r5,r17
  104790:	9009883a 	mov	r4,r18
  104794:	103ee83a 	callr	r2
  104798:	843fffc4 	addi	r16,r16,-1
  10479c:	103ff726 	beq	r2,zero,10477c <_gp+0xffff652c>
  1047a0:	00bfffc4 	movi	r2,-1
  1047a4:	00000106 	br	1047ac <print_repeat+0x54>
  1047a8:	0005883a 	mov	r2,zero
  1047ac:	dfc00417 	ldw	ra,16(sp)
  1047b0:	dc800317 	ldw	r18,12(sp)
  1047b4:	dc400217 	ldw	r17,8(sp)
  1047b8:	dc000117 	ldw	r16,4(sp)
  1047bc:	dec00504 	addi	sp,sp,20
  1047c0:	f800283a 	ret

001047c4 <___vfprintf_internal_r>:
  1047c4:	deffe504 	addi	sp,sp,-108
  1047c8:	d8c00804 	addi	r3,sp,32
  1047cc:	ddc01815 	stw	r23,96(sp)
  1047d0:	dd801715 	stw	r22,92(sp)
  1047d4:	dd401615 	stw	r21,88(sp)
  1047d8:	dd001515 	stw	r20,84(sp)
  1047dc:	dcc01415 	stw	r19,80(sp)
  1047e0:	dc801315 	stw	r18,76(sp)
  1047e4:	dc401215 	stw	r17,72(sp)
  1047e8:	dc001115 	stw	r16,68(sp)
  1047ec:	dfc01a15 	stw	ra,104(sp)
  1047f0:	df001915 	stw	fp,100(sp)
  1047f4:	2029883a 	mov	r20,r4
  1047f8:	2823883a 	mov	r17,r5
  1047fc:	382d883a 	mov	r22,r7
  104800:	d9800f15 	stw	r6,60(sp)
  104804:	0021883a 	mov	r16,zero
  104808:	d8000e15 	stw	zero,56(sp)
  10480c:	d8000a15 	stw	zero,40(sp)
  104810:	002b883a 	mov	r21,zero
  104814:	0027883a 	mov	r19,zero
  104818:	0025883a 	mov	r18,zero
  10481c:	d8000c15 	stw	zero,48(sp)
  104820:	d8000b15 	stw	zero,44(sp)
  104824:	002f883a 	mov	r23,zero
  104828:	d8c00915 	stw	r3,36(sp)
  10482c:	d8c00f17 	ldw	r3,60(sp)
  104830:	19000003 	ldbu	r4,0(r3)
  104834:	20803fcc 	andi	r2,r4,255
  104838:	1080201c 	xori	r2,r2,128
  10483c:	10bfe004 	addi	r2,r2,-128
  104840:	10011e26 	beq	r2,zero,104cbc <___vfprintf_internal_r+0x4f8>
  104844:	00c00044 	movi	r3,1
  104848:	b8c01426 	beq	r23,r3,10489c <___vfprintf_internal_r+0xd8>
  10484c:	1dc00216 	blt	r3,r23,104858 <___vfprintf_internal_r+0x94>
  104850:	b8000626 	beq	r23,zero,10486c <___vfprintf_internal_r+0xa8>
  104854:	00011506 	br	104cac <___vfprintf_internal_r+0x4e8>
  104858:	01400084 	movi	r5,2
  10485c:	b9401d26 	beq	r23,r5,1048d4 <___vfprintf_internal_r+0x110>
  104860:	014000c4 	movi	r5,3
  104864:	b9402b26 	beq	r23,r5,104914 <___vfprintf_internal_r+0x150>
  104868:	00011006 	br	104cac <___vfprintf_internal_r+0x4e8>
  10486c:	01400944 	movi	r5,37
  104870:	1140fc26 	beq	r2,r5,104c64 <___vfprintf_internal_r+0x4a0>
  104874:	88800117 	ldw	r2,4(r17)
  104878:	d9000005 	stb	r4,0(sp)
  10487c:	01c00044 	movi	r7,1
  104880:	d80d883a 	mov	r6,sp
  104884:	880b883a 	mov	r5,r17
  104888:	a009883a 	mov	r4,r20
  10488c:	103ee83a 	callr	r2
  104890:	1000d81e 	bne	r2,zero,104bf4 <___vfprintf_internal_r+0x430>
  104894:	84000044 	addi	r16,r16,1
  104898:	00010406 	br	104cac <___vfprintf_internal_r+0x4e8>
  10489c:	01400c04 	movi	r5,48
  1048a0:	1140fa26 	beq	r2,r5,104c8c <___vfprintf_internal_r+0x4c8>
  1048a4:	01400944 	movi	r5,37
  1048a8:	11400a1e 	bne	r2,r5,1048d4 <___vfprintf_internal_r+0x110>
  1048ac:	d8800005 	stb	r2,0(sp)
  1048b0:	88800117 	ldw	r2,4(r17)
  1048b4:	b80f883a 	mov	r7,r23
  1048b8:	d80d883a 	mov	r6,sp
  1048bc:	880b883a 	mov	r5,r17
  1048c0:	a009883a 	mov	r4,r20
  1048c4:	103ee83a 	callr	r2
  1048c8:	1000ca1e 	bne	r2,zero,104bf4 <___vfprintf_internal_r+0x430>
  1048cc:	84000044 	addi	r16,r16,1
  1048d0:	0000f506 	br	104ca8 <___vfprintf_internal_r+0x4e4>
  1048d4:	25fff404 	addi	r23,r4,-48
  1048d8:	bdc03fcc 	andi	r23,r23,255
  1048dc:	00c00244 	movi	r3,9
  1048e0:	1dc00936 	bltu	r3,r23,104908 <___vfprintf_internal_r+0x144>
  1048e4:	00bfffc4 	movi	r2,-1
  1048e8:	90800426 	beq	r18,r2,1048fc <___vfprintf_internal_r+0x138>
  1048ec:	01400284 	movi	r5,10
  1048f0:	9009883a 	mov	r4,r18
  1048f4:	0104e1c0 	call	104e1c <__mulsi3>
  1048f8:	00000106 	br	104900 <___vfprintf_internal_r+0x13c>
  1048fc:	0005883a 	mov	r2,zero
  104900:	b8a5883a 	add	r18,r23,r2
  104904:	0000e206 	br	104c90 <___vfprintf_internal_r+0x4cc>
  104908:	01400b84 	movi	r5,46
  10490c:	1140e426 	beq	r2,r5,104ca0 <___vfprintf_internal_r+0x4dc>
  104910:	05c00084 	movi	r23,2
  104914:	213ff404 	addi	r4,r4,-48
  104918:	27003fcc 	andi	fp,r4,255
  10491c:	00c00244 	movi	r3,9
  104920:	1f000936 	bltu	r3,fp,104948 <___vfprintf_internal_r+0x184>
  104924:	00bfffc4 	movi	r2,-1
  104928:	98800426 	beq	r19,r2,10493c <___vfprintf_internal_r+0x178>
  10492c:	01400284 	movi	r5,10
  104930:	9809883a 	mov	r4,r19
  104934:	0104e1c0 	call	104e1c <__mulsi3>
  104938:	00000106 	br	104940 <___vfprintf_internal_r+0x17c>
  10493c:	0005883a 	mov	r2,zero
  104940:	e0a7883a 	add	r19,fp,r2
  104944:	0000d906 	br	104cac <___vfprintf_internal_r+0x4e8>
  104948:	00c01b04 	movi	r3,108
  10494c:	10c0d226 	beq	r2,r3,104c98 <___vfprintf_internal_r+0x4d4>
  104950:	013fffc4 	movi	r4,-1
  104954:	99000226 	beq	r19,r4,104960 <___vfprintf_internal_r+0x19c>
  104958:	d8000b15 	stw	zero,44(sp)
  10495c:	00000106 	br	104964 <___vfprintf_internal_r+0x1a0>
  104960:	04c00044 	movi	r19,1
  104964:	01001a44 	movi	r4,105
  104968:	11001626 	beq	r2,r4,1049c4 <___vfprintf_internal_r+0x200>
  10496c:	20800916 	blt	r4,r2,104994 <___vfprintf_internal_r+0x1d0>
  104970:	010018c4 	movi	r4,99
  104974:	11008826 	beq	r2,r4,104b98 <___vfprintf_internal_r+0x3d4>
  104978:	01001904 	movi	r4,100
  10497c:	11001126 	beq	r2,r4,1049c4 <___vfprintf_internal_r+0x200>
  104980:	01001604 	movi	r4,88
  104984:	1100c81e 	bne	r2,r4,104ca8 <___vfprintf_internal_r+0x4e4>
  104988:	00c00044 	movi	r3,1
  10498c:	d8c00e15 	stw	r3,56(sp)
  104990:	00001506 	br	1049e8 <___vfprintf_internal_r+0x224>
  104994:	01001cc4 	movi	r4,115
  104998:	11009826 	beq	r2,r4,104bfc <___vfprintf_internal_r+0x438>
  10499c:	20800416 	blt	r4,r2,1049b0 <___vfprintf_internal_r+0x1ec>
  1049a0:	01001bc4 	movi	r4,111
  1049a4:	1100c01e 	bne	r2,r4,104ca8 <___vfprintf_internal_r+0x4e4>
  1049a8:	05400204 	movi	r21,8
  1049ac:	00000f06 	br	1049ec <___vfprintf_internal_r+0x228>
  1049b0:	01001d44 	movi	r4,117
  1049b4:	11000d26 	beq	r2,r4,1049ec <___vfprintf_internal_r+0x228>
  1049b8:	01001e04 	movi	r4,120
  1049bc:	11000a26 	beq	r2,r4,1049e8 <___vfprintf_internal_r+0x224>
  1049c0:	0000b906 	br	104ca8 <___vfprintf_internal_r+0x4e4>
  1049c4:	d8c00a17 	ldw	r3,40(sp)
  1049c8:	b7000104 	addi	fp,r22,4
  1049cc:	18000726 	beq	r3,zero,1049ec <___vfprintf_internal_r+0x228>
  1049d0:	df000d15 	stw	fp,52(sp)
  1049d4:	b5c00017 	ldw	r23,0(r22)
  1049d8:	b800080e 	bge	r23,zero,1049fc <___vfprintf_internal_r+0x238>
  1049dc:	05efc83a 	sub	r23,zero,r23
  1049e0:	02400044 	movi	r9,1
  1049e4:	00000606 	br	104a00 <___vfprintf_internal_r+0x23c>
  1049e8:	05400404 	movi	r21,16
  1049ec:	b0c00104 	addi	r3,r22,4
  1049f0:	d8c00d15 	stw	r3,52(sp)
  1049f4:	b5c00017 	ldw	r23,0(r22)
  1049f8:	d8000a15 	stw	zero,40(sp)
  1049fc:	0013883a 	mov	r9,zero
  104a00:	d839883a 	mov	fp,sp
  104a04:	b8001726 	beq	r23,zero,104a64 <___vfprintf_internal_r+0x2a0>
  104a08:	a80b883a 	mov	r5,r21
  104a0c:	b809883a 	mov	r4,r23
  104a10:	da401015 	stw	r9,64(sp)
  104a14:	01045640 	call	104564 <__udivsi3>
  104a18:	a80b883a 	mov	r5,r21
  104a1c:	1009883a 	mov	r4,r2
  104a20:	102d883a 	mov	r22,r2
  104a24:	0104e1c0 	call	104e1c <__mulsi3>
  104a28:	b885c83a 	sub	r2,r23,r2
  104a2c:	00c00244 	movi	r3,9
  104a30:	da401017 	ldw	r9,64(sp)
  104a34:	18800216 	blt	r3,r2,104a40 <___vfprintf_internal_r+0x27c>
  104a38:	10800c04 	addi	r2,r2,48
  104a3c:	00000506 	br	104a54 <___vfprintf_internal_r+0x290>
  104a40:	d8c00e17 	ldw	r3,56(sp)
  104a44:	18000226 	beq	r3,zero,104a50 <___vfprintf_internal_r+0x28c>
  104a48:	10800dc4 	addi	r2,r2,55
  104a4c:	00000106 	br	104a54 <___vfprintf_internal_r+0x290>
  104a50:	108015c4 	addi	r2,r2,87
  104a54:	e0800005 	stb	r2,0(fp)
  104a58:	b02f883a 	mov	r23,r22
  104a5c:	e7000044 	addi	fp,fp,1
  104a60:	003fe806 	br	104a04 <_gp+0xffff67b4>
  104a64:	e6efc83a 	sub	r23,fp,sp
  104a68:	9dc5c83a 	sub	r2,r19,r23
  104a6c:	0080090e 	bge	zero,r2,104a94 <___vfprintf_internal_r+0x2d0>
  104a70:	e085883a 	add	r2,fp,r2
  104a74:	01400c04 	movi	r5,48
  104a78:	d8c00917 	ldw	r3,36(sp)
  104a7c:	e009883a 	mov	r4,fp
  104a80:	e0c0032e 	bgeu	fp,r3,104a90 <___vfprintf_internal_r+0x2cc>
  104a84:	e7000044 	addi	fp,fp,1
  104a88:	21400005 	stb	r5,0(r4)
  104a8c:	e0bffa1e 	bne	fp,r2,104a78 <_gp+0xffff6828>
  104a90:	e6efc83a 	sub	r23,fp,sp
  104a94:	d8c00b17 	ldw	r3,44(sp)
  104a98:	4dd1883a 	add	r8,r9,r23
  104a9c:	922dc83a 	sub	r22,r18,r8
  104aa0:	18001626 	beq	r3,zero,104afc <___vfprintf_internal_r+0x338>
  104aa4:	48000a26 	beq	r9,zero,104ad0 <___vfprintf_internal_r+0x30c>
  104aa8:	00800b44 	movi	r2,45
  104aac:	d8800805 	stb	r2,32(sp)
  104ab0:	88800117 	ldw	r2,4(r17)
  104ab4:	01c00044 	movi	r7,1
  104ab8:	d9800804 	addi	r6,sp,32
  104abc:	880b883a 	mov	r5,r17
  104ac0:	a009883a 	mov	r4,r20
  104ac4:	103ee83a 	callr	r2
  104ac8:	10004a1e 	bne	r2,zero,104bf4 <___vfprintf_internal_r+0x430>
  104acc:	84000044 	addi	r16,r16,1
  104ad0:	0580070e 	bge	zero,r22,104af0 <___vfprintf_internal_r+0x32c>
  104ad4:	b00f883a 	mov	r7,r22
  104ad8:	01800c04 	movi	r6,48
  104adc:	880b883a 	mov	r5,r17
  104ae0:	a009883a 	mov	r4,r20
  104ae4:	01047580 	call	104758 <print_repeat>
  104ae8:	1000421e 	bne	r2,zero,104bf4 <___vfprintf_internal_r+0x430>
  104aec:	85a1883a 	add	r16,r16,r22
  104af0:	e02d883a 	mov	r22,fp
  104af4:	bf2fc83a 	sub	r23,r23,fp
  104af8:	00002006 	br	104b7c <___vfprintf_internal_r+0x3b8>
  104afc:	0580090e 	bge	zero,r22,104b24 <___vfprintf_internal_r+0x360>
  104b00:	b00f883a 	mov	r7,r22
  104b04:	01800804 	movi	r6,32
  104b08:	880b883a 	mov	r5,r17
  104b0c:	a009883a 	mov	r4,r20
  104b10:	da401015 	stw	r9,64(sp)
  104b14:	01047580 	call	104758 <print_repeat>
  104b18:	da401017 	ldw	r9,64(sp)
  104b1c:	1000351e 	bne	r2,zero,104bf4 <___vfprintf_internal_r+0x430>
  104b20:	85a1883a 	add	r16,r16,r22
  104b24:	483ff226 	beq	r9,zero,104af0 <_gp+0xffff68a0>
  104b28:	00800b44 	movi	r2,45
  104b2c:	d8800805 	stb	r2,32(sp)
  104b30:	88800117 	ldw	r2,4(r17)
  104b34:	01c00044 	movi	r7,1
  104b38:	d9800804 	addi	r6,sp,32
  104b3c:	880b883a 	mov	r5,r17
  104b40:	a009883a 	mov	r4,r20
  104b44:	103ee83a 	callr	r2
  104b48:	10002a1e 	bne	r2,zero,104bf4 <___vfprintf_internal_r+0x430>
  104b4c:	84000044 	addi	r16,r16,1
  104b50:	003fe706 	br	104af0 <_gp+0xffff68a0>
  104b54:	b5bfffc4 	addi	r22,r22,-1
  104b58:	b0800003 	ldbu	r2,0(r22)
  104b5c:	01c00044 	movi	r7,1
  104b60:	d9800804 	addi	r6,sp,32
  104b64:	d8800805 	stb	r2,32(sp)
  104b68:	88800117 	ldw	r2,4(r17)
  104b6c:	880b883a 	mov	r5,r17
  104b70:	a009883a 	mov	r4,r20
  104b74:	103ee83a 	callr	r2
  104b78:	10001e1e 	bne	r2,zero,104bf4 <___vfprintf_internal_r+0x430>
  104b7c:	8585c83a 	sub	r2,r16,r22
  104b80:	b5c9883a 	add	r4,r22,r23
  104b84:	e085883a 	add	r2,fp,r2
  104b88:	013ff216 	blt	zero,r4,104b54 <_gp+0xffff6904>
  104b8c:	1021883a 	mov	r16,r2
  104b90:	dd800d17 	ldw	r22,52(sp)
  104b94:	00004406 	br	104ca8 <___vfprintf_internal_r+0x4e4>
  104b98:	00800044 	movi	r2,1
  104b9c:	1480080e 	bge	r2,r18,104bc0 <___vfprintf_internal_r+0x3fc>
  104ba0:	95ffffc4 	addi	r23,r18,-1
  104ba4:	b80f883a 	mov	r7,r23
  104ba8:	01800804 	movi	r6,32
  104bac:	880b883a 	mov	r5,r17
  104bb0:	a009883a 	mov	r4,r20
  104bb4:	01047580 	call	104758 <print_repeat>
  104bb8:	10000e1e 	bne	r2,zero,104bf4 <___vfprintf_internal_r+0x430>
  104bbc:	85e1883a 	add	r16,r16,r23
  104bc0:	b0800017 	ldw	r2,0(r22)
  104bc4:	01c00044 	movi	r7,1
  104bc8:	d80d883a 	mov	r6,sp
  104bcc:	d8800005 	stb	r2,0(sp)
  104bd0:	88800117 	ldw	r2,4(r17)
  104bd4:	880b883a 	mov	r5,r17
  104bd8:	a009883a 	mov	r4,r20
  104bdc:	b5c00104 	addi	r23,r22,4
  104be0:	103ee83a 	callr	r2
  104be4:	1000031e 	bne	r2,zero,104bf4 <___vfprintf_internal_r+0x430>
  104be8:	84000044 	addi	r16,r16,1
  104bec:	b82d883a 	mov	r22,r23
  104bf0:	00002d06 	br	104ca8 <___vfprintf_internal_r+0x4e4>
  104bf4:	00bfffc4 	movi	r2,-1
  104bf8:	00003106 	br	104cc0 <___vfprintf_internal_r+0x4fc>
  104bfc:	b5c00017 	ldw	r23,0(r22)
  104c00:	b7000104 	addi	fp,r22,4
  104c04:	b809883a 	mov	r4,r23
  104c08:	010473c0 	call	10473c <strlen>
  104c0c:	9091c83a 	sub	r8,r18,r2
  104c10:	102d883a 	mov	r22,r2
  104c14:	0200090e 	bge	zero,r8,104c3c <___vfprintf_internal_r+0x478>
  104c18:	400f883a 	mov	r7,r8
  104c1c:	01800804 	movi	r6,32
  104c20:	880b883a 	mov	r5,r17
  104c24:	a009883a 	mov	r4,r20
  104c28:	da001015 	stw	r8,64(sp)
  104c2c:	01047580 	call	104758 <print_repeat>
  104c30:	da001017 	ldw	r8,64(sp)
  104c34:	103fef1e 	bne	r2,zero,104bf4 <_gp+0xffff69a4>
  104c38:	8221883a 	add	r16,r16,r8
  104c3c:	88800117 	ldw	r2,4(r17)
  104c40:	b00f883a 	mov	r7,r22
  104c44:	b80d883a 	mov	r6,r23
  104c48:	880b883a 	mov	r5,r17
  104c4c:	a009883a 	mov	r4,r20
  104c50:	103ee83a 	callr	r2
  104c54:	103fe71e 	bne	r2,zero,104bf4 <_gp+0xffff69a4>
  104c58:	85a1883a 	add	r16,r16,r22
  104c5c:	e02d883a 	mov	r22,fp
  104c60:	00001106 	br	104ca8 <___vfprintf_internal_r+0x4e4>
  104c64:	00c00044 	movi	r3,1
  104c68:	04ffffc4 	movi	r19,-1
  104c6c:	d8000e15 	stw	zero,56(sp)
  104c70:	d8c00a15 	stw	r3,40(sp)
  104c74:	05400284 	movi	r21,10
  104c78:	9825883a 	mov	r18,r19
  104c7c:	d8000c15 	stw	zero,48(sp)
  104c80:	d8000b15 	stw	zero,44(sp)
  104c84:	182f883a 	mov	r23,r3
  104c88:	00000806 	br	104cac <___vfprintf_internal_r+0x4e8>
  104c8c:	ddc00b15 	stw	r23,44(sp)
  104c90:	05c00084 	movi	r23,2
  104c94:	00000506 	br	104cac <___vfprintf_internal_r+0x4e8>
  104c98:	00c00044 	movi	r3,1
  104c9c:	d8c00c15 	stw	r3,48(sp)
  104ca0:	05c000c4 	movi	r23,3
  104ca4:	00000106 	br	104cac <___vfprintf_internal_r+0x4e8>
  104ca8:	002f883a 	mov	r23,zero
  104cac:	d8c00f17 	ldw	r3,60(sp)
  104cb0:	18c00044 	addi	r3,r3,1
  104cb4:	d8c00f15 	stw	r3,60(sp)
  104cb8:	003edc06 	br	10482c <_gp+0xffff65dc>
  104cbc:	8005883a 	mov	r2,r16
  104cc0:	dfc01a17 	ldw	ra,104(sp)
  104cc4:	df001917 	ldw	fp,100(sp)
  104cc8:	ddc01817 	ldw	r23,96(sp)
  104ccc:	dd801717 	ldw	r22,92(sp)
  104cd0:	dd401617 	ldw	r21,88(sp)
  104cd4:	dd001517 	ldw	r20,84(sp)
  104cd8:	dcc01417 	ldw	r19,80(sp)
  104cdc:	dc801317 	ldw	r18,76(sp)
  104ce0:	dc401217 	ldw	r17,72(sp)
  104ce4:	dc001117 	ldw	r16,68(sp)
  104ce8:	dec01b04 	addi	sp,sp,108
  104cec:	f800283a 	ret

00104cf0 <__vfprintf_internal>:
  104cf0:	00800434 	movhi	r2,16
  104cf4:	10989504 	addi	r2,r2,25172
  104cf8:	300f883a 	mov	r7,r6
  104cfc:	280d883a 	mov	r6,r5
  104d00:	200b883a 	mov	r5,r4
  104d04:	11000017 	ldw	r4,0(r2)
  104d08:	01047c41 	jmpi	1047c4 <___vfprintf_internal_r>

00104d0c <__sfvwrite_small_dev>:
  104d0c:	2880000b 	ldhu	r2,0(r5)
  104d10:	1080020c 	andi	r2,r2,8
  104d14:	10002126 	beq	r2,zero,104d9c <__sfvwrite_small_dev+0x90>
  104d18:	2880008f 	ldh	r2,2(r5)
  104d1c:	defffa04 	addi	sp,sp,-24
  104d20:	dc000015 	stw	r16,0(sp)
  104d24:	dfc00515 	stw	ra,20(sp)
  104d28:	dd000415 	stw	r20,16(sp)
  104d2c:	dcc00315 	stw	r19,12(sp)
  104d30:	dc800215 	stw	r18,8(sp)
  104d34:	dc400115 	stw	r17,4(sp)
  104d38:	2821883a 	mov	r16,r5
  104d3c:	10001216 	blt	r2,zero,104d88 <__sfvwrite_small_dev+0x7c>
  104d40:	2027883a 	mov	r19,r4
  104d44:	3025883a 	mov	r18,r6
  104d48:	3823883a 	mov	r17,r7
  104d4c:	05010004 	movi	r20,1024
  104d50:	04400b0e 	bge	zero,r17,104d80 <__sfvwrite_small_dev+0x74>
  104d54:	880f883a 	mov	r7,r17
  104d58:	a440010e 	bge	r20,r17,104d60 <__sfvwrite_small_dev+0x54>
  104d5c:	01c10004 	movi	r7,1024
  104d60:	8140008f 	ldh	r5,2(r16)
  104d64:	900d883a 	mov	r6,r18
  104d68:	9809883a 	mov	r4,r19
  104d6c:	0104dc40 	call	104dc4 <_write_r>
  104d70:	0080050e 	bge	zero,r2,104d88 <__sfvwrite_small_dev+0x7c>
  104d74:	88a3c83a 	sub	r17,r17,r2
  104d78:	90a5883a 	add	r18,r18,r2
  104d7c:	003ff406 	br	104d50 <_gp+0xffff6b00>
  104d80:	0005883a 	mov	r2,zero
  104d84:	00000706 	br	104da4 <__sfvwrite_small_dev+0x98>
  104d88:	8080000b 	ldhu	r2,0(r16)
  104d8c:	10801014 	ori	r2,r2,64
  104d90:	8080000d 	sth	r2,0(r16)
  104d94:	00bfffc4 	movi	r2,-1
  104d98:	00000206 	br	104da4 <__sfvwrite_small_dev+0x98>
  104d9c:	00bfffc4 	movi	r2,-1
  104da0:	f800283a 	ret
  104da4:	dfc00517 	ldw	ra,20(sp)
  104da8:	dd000417 	ldw	r20,16(sp)
  104dac:	dcc00317 	ldw	r19,12(sp)
  104db0:	dc800217 	ldw	r18,8(sp)
  104db4:	dc400117 	ldw	r17,4(sp)
  104db8:	dc000017 	ldw	r16,0(sp)
  104dbc:	dec00604 	addi	sp,sp,24
  104dc0:	f800283a 	ret

00104dc4 <_write_r>:
  104dc4:	defffd04 	addi	sp,sp,-12
  104dc8:	dc000015 	stw	r16,0(sp)
  104dcc:	04000434 	movhi	r16,16
  104dd0:	dc400115 	stw	r17,4(sp)
  104dd4:	84193104 	addi	r16,r16,25796
  104dd8:	2023883a 	mov	r17,r4
  104ddc:	2809883a 	mov	r4,r5
  104de0:	300b883a 	mov	r5,r6
  104de4:	380d883a 	mov	r6,r7
  104de8:	dfc00215 	stw	ra,8(sp)
  104dec:	80000015 	stw	zero,0(r16)
  104df0:	0104f540 	call	104f54 <write>
  104df4:	00ffffc4 	movi	r3,-1
  104df8:	10c0031e 	bne	r2,r3,104e08 <_write_r+0x44>
  104dfc:	80c00017 	ldw	r3,0(r16)
  104e00:	18000126 	beq	r3,zero,104e08 <_write_r+0x44>
  104e04:	88c00015 	stw	r3,0(r17)
  104e08:	dfc00217 	ldw	ra,8(sp)
  104e0c:	dc400117 	ldw	r17,4(sp)
  104e10:	dc000017 	ldw	r16,0(sp)
  104e14:	dec00304 	addi	sp,sp,12
  104e18:	f800283a 	ret

00104e1c <__mulsi3>:
  104e1c:	0005883a 	mov	r2,zero
  104e20:	20000726 	beq	r4,zero,104e40 <__mulsi3+0x24>
  104e24:	20c0004c 	andi	r3,r4,1
  104e28:	2008d07a 	srli	r4,r4,1
  104e2c:	18000126 	beq	r3,zero,104e34 <__mulsi3+0x18>
  104e30:	1145883a 	add	r2,r2,r5
  104e34:	294b883a 	add	r5,r5,r5
  104e38:	203ffa1e 	bne	r4,zero,104e24 <_gp+0xffff6bd4>
  104e3c:	f800283a 	ret
  104e40:	f800283a 	ret

00104e44 <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
  104e44:	deffff04 	addi	sp,sp,-4
  104e48:	01000434 	movhi	r4,16
  104e4c:	01400434 	movhi	r5,16
  104e50:	dfc00015 	stw	ra,0(sp)
  104e54:	21180d04 	addi	r4,r4,24628
  104e58:	29589f04 	addi	r5,r5,25212

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  104e5c:	2140061e 	bne	r4,r5,104e78 <alt_load+0x34>
  104e60:	01000434 	movhi	r4,16
  104e64:	01400434 	movhi	r5,16
  104e68:	21100804 	addi	r4,r4,16416
  104e6c:	29500804 	addi	r5,r5,16416
  104e70:	2140121e 	bne	r4,r5,104ebc <alt_load+0x78>
  104e74:	00000b06 	br	104ea4 <alt_load+0x60>
  104e78:	00c00434 	movhi	r3,16
  104e7c:	18d89f04 	addi	r3,r3,25212
  104e80:	1907c83a 	sub	r3,r3,r4
  104e84:	0005883a 	mov	r2,zero
  {
    while( to != end )
  104e88:	10fff526 	beq	r2,r3,104e60 <_gp+0xffff6c10>
    {
      *to++ = *from++;
  104e8c:	114f883a 	add	r7,r2,r5
  104e90:	39c00017 	ldw	r7,0(r7)
  104e94:	110d883a 	add	r6,r2,r4
  104e98:	10800104 	addi	r2,r2,4
  104e9c:	31c00015 	stw	r7,0(r6)
  104ea0:	003ff906 	br	104e88 <_gp+0xffff6c38>
  104ea4:	01000434 	movhi	r4,16
  104ea8:	01400434 	movhi	r5,16
  104eac:	2117cb04 	addi	r4,r4,24364
  104eb0:	2957cb04 	addi	r5,r5,24364

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  104eb4:	2140101e 	bne	r4,r5,104ef8 <alt_load+0xb4>
  104eb8:	00000b06 	br	104ee8 <alt_load+0xa4>
  104ebc:	00c00434 	movhi	r3,16
  104ec0:	18d06004 	addi	r3,r3,16768
  104ec4:	1907c83a 	sub	r3,r3,r4
  104ec8:	0005883a 	mov	r2,zero
  {
    while( to != end )
  104ecc:	10fff526 	beq	r2,r3,104ea4 <_gp+0xffff6c54>
    {
      *to++ = *from++;
  104ed0:	114f883a 	add	r7,r2,r5
  104ed4:	39c00017 	ldw	r7,0(r7)
  104ed8:	110d883a 	add	r6,r2,r4
  104edc:	10800104 	addi	r2,r2,4
  104ee0:	31c00015 	stw	r7,0(r6)
  104ee4:	003ff906 	br	104ecc <_gp+0xffff6c7c>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
  104ee8:	0105c180 	call	105c18 <alt_dcache_flush_all>
  alt_icache_flush_all();
}
  104eec:	dfc00017 	ldw	ra,0(sp)
  104ef0:	dec00104 	addi	sp,sp,4
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
  alt_icache_flush_all();
  104ef4:	0105d601 	jmpi	105d60 <alt_icache_flush_all>
  104ef8:	00c00434 	movhi	r3,16
  104efc:	18d80d04 	addi	r3,r3,24628
  104f00:	1907c83a 	sub	r3,r3,r4

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  104f04:	0005883a 	mov	r2,zero
  {
    while( to != end )
  104f08:	18bff726 	beq	r3,r2,104ee8 <_gp+0xffff6c98>
    {
      *to++ = *from++;
  104f0c:	114f883a 	add	r7,r2,r5
  104f10:	39c00017 	ldw	r7,0(r7)
  104f14:	110d883a 	add	r6,r2,r4
  104f18:	10800104 	addi	r2,r2,4
  104f1c:	31c00015 	stw	r7,0(r6)
  104f20:	003ff906 	br	104f08 <_gp+0xffff6cb8>

00104f24 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
  104f24:	deffff04 	addi	sp,sp,-4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
  104f28:	0009883a 	mov	r4,zero
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
  104f2c:	dfc00015 	stw	ra,0(sp)
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
  104f30:	0104fb40 	call	104fb4 <alt_irq_init>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
  104f34:	0104fd40 	call	104fd4 <alt_sys_init>
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
  104f38:	d1a09e17 	ldw	r6,-32136(gp)
  104f3c:	d1609f17 	ldw	r5,-32132(gp)
  104f40:	d120a017 	ldw	r4,-32128(gp)
  close(STDOUT_FILENO);
  exit (result);
#endif

  ALT_LOG_PRINT_BOOT("[alt_main.c] After main - we should not be here?.\r\n");
}
  104f44:	dfc00017 	ldw	ra,0(sp)
  104f48:	dec00104 	addi	sp,sp,4
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
  104f4c:	010425c1 	jmpi	10425c <main>

00104f50 <usleep>:
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
  return alt_busy_sleep(us);
  104f50:	0105b9c1 	jmpi	105b9c <alt_busy_sleep>

00104f54 <write>:
#if !defined(ALT_STDOUT_PRESENT) && !defined(ALT_STDERR_PRESENT)
    /* Generate a link time warning, should this function ever be called. */
    ALT_STUB_WARNING(write);
#endif

    switch (file) {
  104f54:	00800044 	movi	r2,1
  104f58:	20800226 	beq	r4,r2,104f64 <write+0x10>
  104f5c:	00800084 	movi	r2,2
  104f60:	2080041e 	bne	r4,r2,104f74 <write+0x20>
    case 1: /* stdout file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDOUT_DEV, ptr, len, 0);
#endif /* ALT_STDOUT_PRESENT */
#ifdef ALT_STDERR_PRESENT
    case 2: /* stderr file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDERR_DEV, ptr, len, 0);
  104f64:	01000434 	movhi	r4,16
  104f68:	000f883a 	mov	r7,zero
  104f6c:	21189604 	addi	r4,r4,25176
  104f70:	01050041 	jmpi	105004 <altera_avalon_jtag_uart_write>

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  return ((alt_errno) ? alt_errno() : &errno);
  104f74:	d0a00717 	ldw	r2,-32740(gp)
  104f78:	10000926 	beq	r2,zero,104fa0 <write+0x4c>
 * Provide minimal version that just writes to the stdout/stderr devices
 * when provided.
 */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
  104f7c:	deffff04 	addi	sp,sp,-4
  104f80:	dfc00015 	stw	ra,0(sp)
  104f84:	103ee83a 	callr	r2
#ifdef ALT_STDERR_PRESENT
    case 2: /* stderr file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDERR_DEV, ptr, len, 0);
#endif /* ALT_STDERR_PRESENT */
    default:
        ALT_ERRNO = EBADFD;
  104f88:	00c01444 	movi	r3,81
  104f8c:	10c00015 	stw	r3,0(r2)
        return -1;
    }
}
  104f90:	00bfffc4 	movi	r2,-1
  104f94:	dfc00017 	ldw	ra,0(sp)
  104f98:	dec00104 	addi	sp,sp,4
  104f9c:	f800283a 	ret
  104fa0:	d0a09d04 	addi	r2,gp,-32140
#ifdef ALT_STDERR_PRESENT
    case 2: /* stderr file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDERR_DEV, ptr, len, 0);
#endif /* ALT_STDERR_PRESENT */
    default:
        ALT_ERRNO = EBADFD;
  104fa4:	00c01444 	movi	r3,81
  104fa8:	10c00015 	stw	r3,0(r2)
        return -1;
    }
}
  104fac:	00bfffc4 	movi	r2,-1
  104fb0:	f800283a 	ret

00104fb4 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
  104fb4:	deffff04 	addi	sp,sp,-4
  104fb8:	dfc00015 	stw	ra,0(sp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( NIOS, nios);
  104fbc:	0105e580 	call	105e58 <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
  104fc0:	00800044 	movi	r2,1
  104fc4:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
  104fc8:	dfc00017 	ldw	ra,0(sp)
  104fcc:	dec00104 	addi	sp,sp,4
  104fd0:	f800283a 	ret

00104fd4 <alt_sys_init>:
{
    ALTERA_AVALON_TIMER_INIT ( TIMER0, timer0);
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART, jtag_uart);
    ALTERA_AVALON_SPI_INIT ( SPI_LIS3DH, spi_lis3dh);
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYS_ID, sys_id);
    ALTERA_MODULAR_ADC_INIT ( ADC0, adc0);
  104fd4:	01bfffc4 	movi	r6,-1
  104fd8:	01000434 	movhi	r4,16
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
  104fdc:	deffff04 	addi	sp,sp,-4
    ALTERA_AVALON_TIMER_INIT ( TIMER0, timer0);
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART, jtag_uart);
    ALTERA_AVALON_SPI_INIT ( SPI_LIS3DH, spi_lis3dh);
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYS_ID, sys_id);
    ALTERA_MODULAR_ADC_INIT ( ADC0, adc0);
  104fe0:	300b883a 	mov	r5,r6
  104fe4:	21188504 	addi	r4,r4,25108
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
  104fe8:	dfc00015 	stw	ra,0(sp)
    ALTERA_AVALON_TIMER_INIT ( TIMER0, timer0);
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART, jtag_uart);
    ALTERA_AVALON_SPI_INIT ( SPI_LIS3DH, spi_lis3dh);
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYS_ID, sys_id);
    ALTERA_MODULAR_ADC_INIT ( ADC0, adc0);
  104fec:	01051580 	call	105158 <altera_modular_adc_init>
    ALTERA_ONCHIP_FLASH_INIT ( ONCHIP_FLASH, onchip_flash);
  104ff0:	01000434 	movhi	r4,16
  104ff4:	21184504 	addi	r4,r4,24852
}
  104ff8:	dfc00017 	ldw	ra,0(sp)
  104ffc:	dec00104 	addi	sp,sp,4
    ALTERA_AVALON_TIMER_INIT ( TIMER0, timer0);
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART, jtag_uart);
    ALTERA_AVALON_SPI_INIT ( SPI_LIS3DH, spi_lis3dh);
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYS_ID, sys_id);
    ALTERA_MODULAR_ADC_INIT ( ADC0, adc0);
    ALTERA_ONCHIP_FLASH_INIT ( ONCHIP_FLASH, onchip_flash);
  105000:	01055bc1 	jmpi	1055bc <altera_onchip_flash_init>

00105004 <altera_avalon_jtag_uart_write>:
 */

int altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
  unsigned int base = sp->base;
  105004:	21000017 	ldw	r4,0(r4)
 * one FIFOs worth of data.  But you said you didn't want to use interrupts :-)
 */

int altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
  105008:	3005883a 	mov	r2,r6
  unsigned int base = sp->base;

  const char * end = ptr + count;
  10500c:	298d883a 	add	r6,r5,r6

  while (ptr < end)
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
  105010:	21c00104 	addi	r7,r4,4
{
  unsigned int base = sp->base;

  const char * end = ptr + count;

  while (ptr < end)
  105014:	2980072e 	bgeu	r5,r6,105034 <altera_avalon_jtag_uart_write+0x30>
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
  105018:	38c00037 	ldwio	r3,0(r7)
  10501c:	18ffffec 	andhi	r3,r3,65535
  105020:	183ffc26 	beq	r3,zero,105014 <_gp+0xffff6dc4>
      IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, *ptr++);
  105024:	28c00007 	ldb	r3,0(r5)
  105028:	20c00035 	stwio	r3,0(r4)
  10502c:	29400044 	addi	r5,r5,1
  105030:	003ff806 	br	105014 <_gp+0xffff6dc4>

  return count;
}
  105034:	f800283a 	ret

00105038 <alt_avalon_spi_command>:

int alt_avalon_spi_command(alt_u32 base, alt_u32 slave,
                           alt_u32 write_length, const alt_u8 * write_data,
                           alt_u32 read_length, alt_u8 * read_data,
                           alt_u32 flags)
{
  105038:	d8800017 	ldw	r2,0(sp)
  10503c:	da000117 	ldw	r8,4(sp)
  /* Warning: this function is not currently safe if called in a multi-threaded
   * environment, something above must perform locking to make it safe if more
   * than one thread intends to use it.
   */

  IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(base, 1 << slave);
  105040:	00c00044 	movi	r3,1

int alt_avalon_spi_command(alt_u32 base, alt_u32 slave,
                           alt_u32 write_length, const alt_u8 * write_data,
                           alt_u32 read_length, alt_u8 * read_data,
                           alt_u32 flags)
{
  105044:	da400217 	ldw	r9,8(sp)
  /* Warning: this function is not currently safe if called in a multi-threaded
   * environment, something above must perform locking to make it safe if more
   * than one thread intends to use it.
   */

  IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(base, 1 << slave);
  105048:	194a983a 	sll	r5,r3,r5
int alt_avalon_spi_command(alt_u32 base, alt_u32 slave,
                           alt_u32 write_length, const alt_u8 * write_data,
                           alt_u32 read_length, alt_u8 * read_data,
                           alt_u32 flags)
{
  const alt_u8 * write_end = write_data + write_length;
  10504c:	399d883a 	add	r14,r7,r6
  alt_u8 * read_end = read_data + read_length;
  105050:	409f883a 	add	r15,r8,r2
  /* Warning: this function is not currently safe if called in a multi-threaded
   * environment, something above must perform locking to make it safe if more
   * than one thread intends to use it.
   */

  IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(base, 1 << slave);
  105054:	21400535 	stwio	r5,20(r4)
  
  /* Set the SSO bit (force chipselect) only if the toggle flag is not set */
  if ((flags & ALT_AVALON_SPI_COMMAND_TOGGLE_SS_N) == 0) {
  105058:	48c0008c 	andi	r3,r9,2
  10505c:	1800021e 	bne	r3,zero,105068 <alt_avalon_spi_command+0x30>
    IOWR_ALTERA_AVALON_SPI_CONTROL(base, ALTERA_AVALON_SPI_CONTROL_SSO_MSK);
  105060:	00c10004 	movi	r3,1024
  105064:	20c00335 	stwio	r3,12(r4)
  /*
   * Discard any stale data present in the RXDATA register, in case
   * previous communication was interrupted and stale data was left
   * behind.
   */
  IORD_ALTERA_AVALON_SPI_RXDATA(base);
  105068:	20c00037 	ldwio	r3,0(r4)

  /* We must not send more than two bytes to the target before it has
   * returned any as otherwise it will overflow. */
  /* Unfortunately the hardware does not seem to work with credits > 1,
   * leave it at 1 for now. */
  alt_32 credits = 1;
  10506c:	00c00044 	movi	r3,1
                           alt_u32 flags)
{
  const alt_u8 * write_end = write_data + write_length;
  alt_u8 * read_end = read_data + read_length;

  alt_u32 write_zeros = read_length;
  105070:	1015883a 	mov	r10,r2
  for ( ; ; )
  {
    
    do
    {
      status = IORD_ALTERA_AVALON_SPI_STATUS(base);
  105074:	22c00204 	addi	r11,r4,8
      if (write_data < write_end)
        IOWR_ALTERA_AVALON_SPI_TXDATA(base, *write_data++);
      else if (write_zeros > 0)
      {
        write_zeros--;
        IOWR_ALTERA_AVALON_SPI_TXDATA(base, 0);
  105078:	23000104 	addi	r12,r4,4
  for ( ; ; )
  {
    
    do
    {
      status = IORD_ALTERA_AVALON_SPI_STATUS(base);
  10507c:	59400037 	ldwio	r5,0(r11)
    }
    while (((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) == 0 || credits == 0) &&
  105080:	2b40100c 	andi	r13,r5,64
  105084:	2940200c 	andi	r5,r5,128
            (status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) == 0);
  105088:	68000126 	beq	r13,zero,105090 <alt_avalon_spi_command+0x58>
    
    do
    {
      status = IORD_ALTERA_AVALON_SPI_STATUS(base);
    }
    while (((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) == 0 || credits == 0) &&
  10508c:	1800031e 	bne	r3,zero,10509c <alt_avalon_spi_command+0x64>
  105090:	283ffa26 	beq	r5,zero,10507c <_gp+0xffff6e2c>
            (status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) == 0);

    if ((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) != 0 && credits > 0)
  105094:	68000e26 	beq	r13,zero,1050d0 <alt_avalon_spi_command+0x98>
  105098:	00001e06 	br	105114 <alt_avalon_spi_command+0xdc>
  10509c:	00c00c0e 	bge	zero,r3,1050d0 <alt_avalon_spi_command+0x98>
    {
      credits--;
  1050a0:	18ffffc4 	addi	r3,r3,-1

      if (write_data < write_end)
  1050a4:	3b80052e 	bgeu	r7,r14,1050bc <alt_avalon_spi_command+0x84>
        IOWR_ALTERA_AVALON_SPI_TXDATA(base, *write_data++);
  1050a8:	3b400044 	addi	r13,r7,1
  1050ac:	39c00003 	ldbu	r7,0(r7)
  1050b0:	61c00035 	stwio	r7,0(r12)
  1050b4:	680f883a 	mov	r7,r13
  1050b8:	00000506 	br	1050d0 <alt_avalon_spi_command+0x98>
      else if (write_zeros > 0)
  1050bc:	50000326 	beq	r10,zero,1050cc <alt_avalon_spi_command+0x94>
      {
        write_zeros--;
  1050c0:	52bfffc4 	addi	r10,r10,-1
        IOWR_ALTERA_AVALON_SPI_TXDATA(base, 0);
  1050c4:	60000035 	stwio	zero,0(r12)
  1050c8:	00000106 	br	1050d0 <alt_avalon_spi_command+0x98>
      }
      else
        credits = -1024;
  1050cc:	00ff0004 	movi	r3,-1024
    };

    if ((status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) != 0)
  1050d0:	283fea26 	beq	r5,zero,10507c <_gp+0xffff6e2c>
    {
      alt_u32 rxdata = IORD_ALTERA_AVALON_SPI_RXDATA(base);
  1050d4:	21400037 	ldwio	r5,0(r4)

      if (read_ignore > 0)
  1050d8:	30000226 	beq	r6,zero,1050e4 <alt_avalon_spi_command+0xac>
        read_ignore--;
  1050dc:	31bfffc4 	addi	r6,r6,-1
  1050e0:	00000206 	br	1050ec <alt_avalon_spi_command+0xb4>
      else
        *read_data++ = (alt_u8)rxdata;
  1050e4:	41400005 	stb	r5,0(r8)
  1050e8:	42000044 	addi	r8,r8,1
      credits++;
  1050ec:	18c00044 	addi	r3,r3,1

      if (read_ignore == 0 && read_data == read_end)
  1050f0:	303fe21e 	bne	r6,zero,10507c <_gp+0xffff6e2c>
  1050f4:	43ffe11e 	bne	r8,r15,10507c <_gp+0xffff6e2c>
  }

  /* Wait until the interface has finished transmitting */
  do
  {
    status = IORD_ALTERA_AVALON_SPI_STATUS(base);
  1050f8:	58c00037 	ldwio	r3,0(r11)
  }
  while ((status & ALTERA_AVALON_SPI_STATUS_TMT_MSK) == 0);
  1050fc:	18c0080c 	andi	r3,r3,32
  105100:	183ffd26 	beq	r3,zero,1050f8 <_gp+0xffff6ea8>

  /* Clear SSO (release chipselect) unless the caller is going to
   * keep using this chip
   */
  if ((flags & ALT_AVALON_SPI_COMMAND_MERGE) == 0)
  105104:	4a40004c 	andi	r9,r9,1
  105108:	4800041e 	bne	r9,zero,10511c <alt_avalon_spi_command+0xe4>
    IOWR_ALTERA_AVALON_SPI_CONTROL(base, 0);
  10510c:	20000335 	stwio	zero,12(r4)

  return read_length;
  105110:	f800283a 	ret
      status = IORD_ALTERA_AVALON_SPI_STATUS(base);
    }
    while (((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) == 0 || credits == 0) &&
            (status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) == 0);

    if ((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) != 0 && credits > 0)
  105114:	00ffef0e 	bge	zero,r3,1050d4 <_gp+0xffff6e84>
  105118:	003fe106 	br	1050a0 <_gp+0xffff6e50>
   */
  if ((flags & ALT_AVALON_SPI_COMMAND_MERGE) == 0)
    IOWR_ALTERA_AVALON_SPI_CONTROL(base, 0);

  return read_length;
}
  10511c:	f800283a 	ret

00105120 <alt_adc_word_read>:
    alt_u32 word_length = len;
    alt_u32* dest_buf = dest_ptr;
    alt_u32 base = sample_store_base;
     
    /* return -EINVAL if invalid arguments passed into function */
    if(NULL == dest_buf)
  105120:	28000b26 	beq	r5,zero,105150 <alt_adc_word_read+0x30>
  105124:	0005883a 	mov	r2,zero
    	return -EINVAL;
    }

    for(word = 0; word < word_length; word++)
    {
       *dest_buf = IORD_32DIRECT((base + (word * 4)),0);
  105128:	2149c83a 	sub	r4,r4,r5
    if(NULL == dest_buf)
    {
    	return -EINVAL;
    }

    for(word = 0; word < word_length; word++)
  10512c:	11800626 	beq	r2,r6,105148 <alt_adc_word_read+0x28>
    {
       *dest_buf = IORD_32DIRECT((base + (word * 4)),0);
  105130:	2907883a 	add	r3,r5,r4
  105134:	18c00037 	ldwio	r3,0(r3)
  105138:	28c00015 	stw	r3,0(r5)
    if(NULL == dest_buf)
    {
    	return -EINVAL;
    }

    for(word = 0; word < word_length; word++)
  10513c:	10800044 	addi	r2,r2,1
    {
       *dest_buf = IORD_32DIRECT((base + (word * 4)),0);

       dest_buf++;
  105140:	29400104 	addi	r5,r5,4
  105144:	003ff906 	br	10512c <_gp+0xffff6edc>
    }

    return 0;
  105148:	0005883a 	mov	r2,zero
  10514c:	f800283a 	ret
    alt_u32 base = sample_store_base;
     
    /* return -EINVAL if invalid arguments passed into function */
    if(NULL == dest_buf)
    {
    	return -EINVAL;
  105150:	00bffa84 	movi	r2,-22
       dest_buf++;
    }

    return 0;

}
  105154:	f800283a 	ret

00105158 <altera_modular_adc_init>:


void altera_modular_adc_init(alt_modular_adc_dev* dev, alt_32 ic_id, alt_32 irq)
{
  105158:	defffb04 	addi	sp,sp,-20
  10515c:	dc000115 	stw	r16,4(sp)
  105160:	2821883a 	mov	r16,r5
    extern alt_llist altera_modular_adc_list;
    alt_dev_llist_insert((alt_dev_llist*) dev, &altera_modular_adc_list);
  105164:	d1600304 	addi	r5,gp,-32756

}


void altera_modular_adc_init(alt_modular_adc_dev* dev, alt_32 ic_id, alt_32 irq)
{
  105168:	dc800315 	stw	r18,12(sp)
  10516c:	dc400215 	stw	r17,8(sp)
  105170:	dfc00415 	stw	ra,16(sp)
  105174:	2025883a 	mov	r18,r4
  105178:	3023883a 	mov	r17,r6
    extern alt_llist altera_modular_adc_list;
    alt_dev_llist_insert((alt_dev_llist*) dev, &altera_modular_adc_list);
  10517c:	0105c1c0 	call	105c1c <alt_dev_llist_insert>
	
	if ((0 <= ic_id) && (0 <= irq))
  105180:	80000816 	blt	r16,zero,1051a4 <altera_modular_adc_init+0x4c>
  105184:	88000716 	blt	r17,zero,1051a4 <altera_modular_adc_init+0x4c>
	{
          /* Install IRQ handler */
	  #ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
              alt_ic_isr_register(ic_id, irq, alt_adc_irq, 
  105188:	01800434 	movhi	r6,16
  10518c:	d8000015 	stw	zero,0(sp)
  105190:	900f883a 	mov	r7,r18
  105194:	3194ad04 	addi	r6,r6,21172
  105198:	880b883a 	mov	r5,r17
  10519c:	8009883a 	mov	r4,r16
  1051a0:	0105d640 	call	105d64 <alt_ic_isr_register>
                      dev, NULL);
          #else
             alt_irq_register(irq, dev, alt_adc_irq);
          #endif 
	}
}
  1051a4:	dfc00417 	ldw	ra,16(sp)
  1051a8:	dc800317 	ldw	r18,12(sp)
  1051ac:	dc400217 	ldw	r17,8(sp)
  1051b0:	dc000117 	ldw	r16,4(sp)
  1051b4:	dec00504 	addi	sp,sp,20
  1051b8:	f800283a 	ret

001051bc <altera_modular_adc_open>:
alt_modular_adc_dev* altera_modular_adc_open (const char *name)
{
    alt_modular_adc_dev *dev = NULL;

    /* Find requested device */
    dev = (alt_modular_adc_dev*) alt_find_dev (name, &altera_modular_adc_list);
  1051bc:	d1600304 	addi	r5,gp,-32756
  1051c0:	0105c881 	jmpi	105c88 <alt_find_dev>

001051c4 <adc_stop>:
    return dev;
}

void adc_stop(int sequencer_base)
{
    ALTERA_MODULAR_ADC_SEQUENCER_STOP(sequencer_base);
  1051c4:	20c00037 	ldwio	r3,0(r4)
  1051c8:	00bfff84 	movi	r2,-2
  1051cc:	1884703a 	and	r2,r3,r2
  1051d0:	20800035 	stwio	r2,0(r4)
  1051d4:	20800037 	ldwio	r2,0(r4)
  1051d8:	1080004c 	andi	r2,r2,1
  1051dc:	103ffd1e 	bne	r2,zero,1051d4 <_gp+0xffff6f84>
}
  1051e0:	f800283a 	ret

001051e4 <adc_start>:

void adc_start(int sequencer_base)
{
    ALTERA_MODULAR_ADC_SEQUENCER_START(sequencer_base);
  1051e4:	20800037 	ldwio	r2,0(r4)
  1051e8:	10800054 	ori	r2,r2,1
  1051ec:	20800035 	stwio	r2,0(r4)
  1051f0:	f800283a 	ret

001051f4 <adc_set_mode_run_once>:

void adc_set_mode_run_once(int sequencer_base)
{
    /* Note: Stop the ADC before calling this function,
       changing ADC mode while RUN bit is set has no effect. */
    ALTERA_MODULAR_ADC_SEQUENCER_MODE_RUN_ONCE(sequencer_base);
  1051f4:	20c00037 	ldwio	r3,0(r4)
  1051f8:	00bffc44 	movi	r2,-15
  1051fc:	1884703a 	and	r2,r3,r2
  105200:	10800094 	ori	r2,r2,2
  105204:	20800035 	stwio	r2,0(r4)
  105208:	f800283a 	ret

0010520c <adc_set_mode_run_continuously>:

void adc_set_mode_run_continuously(int sequencer_base)
{
    /* Note: Stop the ADC before calling this function,
       changing ADC mode while RUN bit is set has no effect. */
    ALTERA_MODULAR_ADC_SEQUENCER_MODE_RUN_CONTINUOUSLY(sequencer_base);
  10520c:	20c00037 	ldwio	r3,0(r4)
  105210:	00bffc44 	movi	r2,-15
  105214:	1884703a 	and	r2,r3,r2
  105218:	20800035 	stwio	r2,0(r4)
  10521c:	f800283a 	ret

00105220 <adc_recalibrate>:
}

void adc_recalibrate(int sequencer_base)
{
  105220:	defffd04 	addi	sp,sp,-12
  105224:	dc000015 	stw	r16,0(sp)
  105228:	2021883a 	mov	r16,r4
  10522c:	dfc00215 	stw	ra,8(sp)
  105230:	dc400115 	stw	r17,4(sp)
         2. Start the ADC Sequencer Core.
         5. Poll for RUN bit to be clear
         6. Restore CMD register
     */
    alt_u32 backup_cmd_reg;
    backup_cmd_reg = IORD_ALTERA_MODULAR_ADC_SEQUENCER_CMD_REG(sequencer_base);
  105234:	24400037 	ldwio	r17,0(r4)
    adc_stop(sequencer_base);
  105238:	01051c40 	call	1051c4 <adc_stop>
    ALTERA_MODULAR_ADC_SEQUENCER_MODE_RUN_RECALIBRATION(sequencer_base);
  10523c:	80800037 	ldwio	r2,0(r16)
  105240:	10800394 	ori	r2,r2,14
  105244:	80800035 	stwio	r2,0(r16)
    adc_start(sequencer_base);
  105248:	8009883a 	mov	r4,r16
  10524c:	01051e40 	call	1051e4 <adc_start>
    while(IORD_ALTERA_MODULAR_ADC_SEQUENCER_CMD_REG(sequencer_base)
  105250:	80800037 	ldwio	r2,0(r16)
  105254:	1080004c 	andi	r2,r2,1
  105258:	103ffd1e 	bne	r2,zero,105250 <_gp+0xffff7000>
             & ALTERA_MODULAR_ADC_SEQUENCER_CMD_RUN_MSK);
    IOWR_ALTERA_MODULAR_ADC_SEQUENCER_CMD_REG(sequencer_base, backup_cmd_reg);
  10525c:	84400035 	stwio	r17,0(r16)
}
  105260:	dfc00217 	ldw	ra,8(sp)
  105264:	dc400117 	ldw	r17,4(sp)
  105268:	dc000017 	ldw	r16,0(sp)
  10526c:	dec00304 	addi	sp,sp,12
  105270:	f800283a 	ret

00105274 <adc_interrupt_enable>:

void adc_interrupt_enable(int sample_store_base)
{
    ALTERA_MODULAR_ADC_SAMPLE_STORAGE_IRQ_ENABLE(sample_store_base);
  105274:	21004004 	addi	r4,r4,256
  105278:	20800037 	ldwio	r2,0(r4)
  10527c:	10800054 	ori	r2,r2,1
  105280:	20800035 	stwio	r2,0(r4)
  105284:	f800283a 	ret

00105288 <adc_interrupt_disable>:
}

void adc_interrupt_disable(int sample_store_base)
{
    ALTERA_MODULAR_ADC_SAMPLE_STORAGE_IRQ_DISABLE(sample_store_base);
  105288:	21004004 	addi	r4,r4,256
  10528c:	20c00037 	ldwio	r3,0(r4)
  105290:	00bfff84 	movi	r2,-2
  105294:	1884703a 	and	r2,r3,r2
  105298:	20800035 	stwio	r2,0(r4)
  10529c:	f800283a 	ret

001052a0 <adc_clear_interrupt_status>:
}

void adc_clear_interrupt_status(int sample_store_base)
{
    CLEAR_ALTERA_MODULAR_ADC_SAMPLE_STORAGE_IRQ_STATUS(sample_store_base);
  1052a0:	21004104 	addi	r4,r4,260
  1052a4:	20800037 	ldwio	r2,0(r4)
  1052a8:	10800054 	ori	r2,r2,1
  1052ac:	20800035 	stwio	r2,0(r4)
  1052b0:	f800283a 	ret

001052b4 <alt_adc_irq>:
static void alt_adc_irq(void *context)
{
    alt_modular_adc_dev *dev = (alt_modular_adc_dev *) context;
    alt_irq_context cpu_sr = 0;

	if(NULL != dev)
  1052b4:	20001426 	beq	r4,zero,105308 <alt_adc_irq+0x54>
 * alt_adc_irq()
 *
 * Interrupt handler for the altera modular adc.
 */
static void alt_adc_irq(void *context)
{
  1052b8:	defffd04 	addi	sp,sp,-12
  1052bc:	dc000015 	stw	r16,0(sp)
  1052c0:	2021883a 	mov	r16,r4
  1052c4:	dfc00215 	stw	ra,8(sp)
  1052c8:	dc400115 	stw	r17,4(sp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  1052cc:	0023303a 	rdctl	r17,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  1052d0:	00bfff84 	movi	r2,-2
  1052d4:	8884703a 	and	r2,r17,r2
  1052d8:	1001703a 	wrctl	status,r2
		* Other interrupts are explicitly disabled if callbacks
		* are registered because there is no guarantee that they are 
		* pre-emption-safe. This allows the driver to support 
		* interrupt pre-emption.
		*/
		if(dev->callback) 
  1052dc:	20800a17 	ldw	r2,40(r4)
  1052e0:	10000226 	beq	r2,zero,1052ec <alt_adc_irq+0x38>
		{
			dev->callback (dev->callback_context);
  1052e4:	21000b17 	ldw	r4,44(r4)
  1052e8:	103ee83a 	callr	r2
		}
    
		/* clear the IRQ status */
		adc_clear_interrupt_status(dev->sample_store_base);
  1052ec:	81000c17 	ldw	r4,48(r16)
  1052f0:	01052a00 	call	1052a0 <adc_clear_interrupt_status>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  1052f4:	8801703a 	wrctl	status,r17
	    
		alt_irq_enable_all(cpu_sr);
	}
	
    return;
}
  1052f8:	dfc00217 	ldw	ra,8(sp)
  1052fc:	dc400117 	ldw	r17,4(sp)
  105300:	dc000017 	ldw	r16,0(sp)
  105304:	dec00304 	addi	sp,sp,12
  105308:	f800283a 	ret

0010530c <alt_adc_register_callback>:
void alt_adc_register_callback(
	alt_modular_adc_dev *dev,
	alt_adc_callback callback,
	void *context,
	alt_u32 sample_store_base)
{
  10530c:	defffe04 	addi	sp,sp,-8
  105310:	dc000015 	stw	r16,0(sp)
  105314:	dfc00115 	stw	ra,4(sp)
    dev->callback         = callback;
  105318:	21400a15 	stw	r5,40(r4)
    dev->callback_context = context;
  10531c:	21800b15 	stw	r6,44(r4)
    dev->sample_store_base = sample_store_base;
  105320:	21c00c15 	stw	r7,48(r4)
void alt_adc_register_callback(
	alt_modular_adc_dev *dev,
	alt_adc_callback callback,
	void *context,
	alt_u32 sample_store_base)
{
  105324:	3821883a 	mov	r16,r7
    dev->callback_context = context;
    dev->sample_store_base = sample_store_base;
	
	if(NULL != callback)
	{
                adc_clear_interrupt_status(sample_store_base);
  105328:	3809883a 	mov	r4,r7
{
    dev->callback         = callback;
    dev->callback_context = context;
    dev->sample_store_base = sample_store_base;
	
	if(NULL != callback)
  10532c:	28000626 	beq	r5,zero,105348 <alt_adc_register_callback+0x3c>
	{
                adc_clear_interrupt_status(sample_store_base);
  105330:	01052a00 	call	1052a0 <adc_clear_interrupt_status>
		adc_interrupt_enable(sample_store_base);
  105334:	8009883a 	mov	r4,r16
	}
	
    
	
    return ;
}
  105338:	dfc00117 	ldw	ra,4(sp)
  10533c:	dc000017 	ldw	r16,0(sp)
  105340:	dec00204 	addi	sp,sp,8
    dev->sample_store_base = sample_store_base;
	
	if(NULL != callback)
	{
                adc_clear_interrupt_status(sample_store_base);
		adc_interrupt_enable(sample_store_base);
  105344:	01052741 	jmpi	105274 <adc_interrupt_enable>
	}
	else
	{
		adc_interrupt_disable(sample_store_base);
  105348:	01052880 	call	105288 <adc_interrupt_disable>
                adc_clear_interrupt_status(sample_store_base);
  10534c:	8009883a 	mov	r4,r16
	}
	
    
	
    return ;
}
  105350:	dfc00117 	ldw	ra,4(sp)
  105354:	dc000017 	ldw	r16,0(sp)
  105358:	dec00204 	addi	sp,sp,8
		adc_interrupt_enable(sample_store_base);
	}
	else
	{
		adc_interrupt_disable(sample_store_base);
                adc_clear_interrupt_status(sample_store_base);
  10535c:	01052a01 	jmpi	1052a0 <adc_clear_interrupt_status>

00105360 <adc_interrupt_asserted>:
    CLEAR_ALTERA_MODULAR_ADC_SAMPLE_STORAGE_IRQ_STATUS(sample_store_base);
}

int adc_interrupt_asserted(int sample_store_base)
{
    return((READ_ALTERA_MODULAR_ADC_SAMPLE_STORAGE_IRQ_STATUS(sample_store_base)==1) ? -1 : 0);
  105360:	20804137 	ldwio	r2,260(r4)
  105364:	1080004c 	andi	r2,r2,1
}
  105368:	0085c83a 	sub	r2,zero,r2
  10536c:	f800283a 	ret

00105370 <adc_wait_for_interrupt>:

void adc_wait_for_interrupt(int sample_store_base)
{
    WAIT_FOR_ALTERA_MODULAR_ADC_SAMPLE_STORAGE_IRQ(sample_store_base);
  105370:	21004104 	addi	r4,r4,260
  105374:	20800037 	ldwio	r2,0(r4)
  105378:	1080004c 	andi	r2,r2,1
  10537c:	103ffd26 	beq	r2,zero,105374 <_gp+0xffff7124>
}
  105380:	f800283a 	ret

00105384 <alt_onchip_flash_read>:
{
    int ret_code = 0;
    alt_onchip_flash_dev* flash = (alt_onchip_flash_dev*)flash_info;

    /* Make sure the input parameters is not outside of this device's range. */
    if ((offset >= flash->dev.length) || ((offset+length) > flash->dev.length)) {
  105384:	20800b17 	ldw	r2,44(r4)
  105388:	2880140e 	bge	r5,r2,1053dc <alt_onchip_flash_read+0x58>
  10538c:	29c7883a 	add	r3,r5,r7
  105390:	10c01216 	blt	r2,r3,1053dc <alt_onchip_flash_read+0x58>
    alt_flash_dev *flash_info,
    int           offset,
    void          *dest_addr,
    int           length
)
{
  105394:	defffe04 	addi	sp,sp,-8
  105398:	dc000015 	stw	r16,0(sp)
  10539c:	2021883a 	mov	r16,r4
    /* Make sure the input parameters is not outside of this device's range. */
    if ((offset >= flash->dev.length) || ((offset+length) > flash->dev.length)) {
        return -EFAULT;
    }
    
    memcpy(dest_addr, (alt_u8*)flash->dev.base_addr+offset, length);
  1053a0:	80800a17 	ldw	r2,40(r16)
  1053a4:	3009883a 	mov	r4,r6
  1053a8:	380d883a 	mov	r6,r7
  1053ac:	114b883a 	add	r5,r2,r5
    alt_flash_dev *flash_info,
    int           offset,
    void          *dest_addr,
    int           length
)
{
  1053b0:	dfc00115 	stw	ra,4(sp)
    /* Make sure the input parameters is not outside of this device's range. */
    if ((offset >= flash->dev.length) || ((offset+length) > flash->dev.length)) {
        return -EFAULT;
    }
    
    memcpy(dest_addr, (alt_u8*)flash->dev.base_addr+offset, length);
  1053b4:	0105f040 	call	105f04 <memcpy>

    if (NULL != flash->csr_base) {
  1053b8:	80802f17 	ldw	r2,188(r16)
  1053bc:	1000021e 	bne	r2,zero,1053c8 <alt_onchip_flash_read+0x44>
    int           offset,
    void          *dest_addr,
    int           length
)
{
    int ret_code = 0;
  1053c0:	0005883a 	mov	r2,zero
  1053c4:	00000706 	br	1053e4 <alt_onchip_flash_read+0x60>
    }
    
    memcpy(dest_addr, (alt_u8*)flash->dev.base_addr+offset, length);

    if (NULL != flash->csr_base) {
        int read_status = IORD_ALTERA_ONCHIP_FLASH_STATUS(flash->csr_base) & ALTERA_ONCHIP_FLASH_STATUS_READ_MSK;
  1053c8:	10800037 	ldwio	r2,0(r2)
        if (read_status != ALTERA_ONCHIP_FLASH_STATUS_READ_PASSED) {
  1053cc:	1080010c 	andi	r2,r2,4
  1053d0:	103ffb1e 	bne	r2,zero,1053c0 <_gp+0xffff7170>
            /* Read failed.  Return error.*/
            ret_code = -EIO;
  1053d4:	00bffec4 	movi	r2,-5
  1053d8:	00000206 	br	1053e4 <alt_onchip_flash_read+0x60>
    int ret_code = 0;
    alt_onchip_flash_dev* flash = (alt_onchip_flash_dev*)flash_info;

    /* Make sure the input parameters is not outside of this device's range. */
    if ((offset >= flash->dev.length) || ((offset+length) > flash->dev.length)) {
        return -EFAULT;
  1053dc:	00bffc84 	movi	r2,-14
  1053e0:	f800283a 	ret
            /* Read failed.  Return error.*/
            ret_code = -EIO;
        }
    }
    return ret_code;
}
  1053e4:	dfc00117 	ldw	ra,4(sp)
  1053e8:	dc000017 	ldw	r16,0(sp)
  1053ec:	dec00204 	addi	sp,sp,8
  1053f0:	f800283a 	ret

001053f4 <alt_onchip_flash_get_info>:
{
    int ret_code = 0;

    alt_flash_dev* flash = (alt_flash_dev*)fd;

    if (NULL != number_of_regions)
  1053f4:	30000226 	beq	r6,zero,105400 <alt_onchip_flash_get_info+0xc>
    {
        /* Pass the number of region to user */
        *number_of_regions = flash->number_of_regions;
  1053f8:	20800c17 	ldw	r2,48(r4)
  1053fc:	30800015 	stw	r2,0(r6)
    }

    if (!flash->number_of_regions)
  105400:	20800c17 	ldw	r2,48(r4)
  105404:	10000626 	beq	r2,zero,105420 <alt_onchip_flash_get_info+0x2c>
    {
        ret_code = -ENOMEM;
    }
    else if (flash->number_of_regions > ALT_MAX_NUMBER_OF_FLASH_REGIONS)
  105408:	00c00204 	movi	r3,8
  10540c:	18800616 	blt	r3,r2,105428 <alt_onchip_flash_get_info+0x34>
    {
        ret_code = -EFAULT;
    }
    else
    {
        if (NULL != info)
  105410:	28000726 	beq	r5,zero,105430 <alt_onchip_flash_get_info+0x3c>
        {
            /* Pass the table of erase blocks to user */
            *info = &flash->region_info[0];
  105414:	21000d04 	addi	r4,r4,52
  105418:	29000015 	stw	r4,0(r5)
  10541c:	00000406 	br	105430 <alt_onchip_flash_get_info+0x3c>
        *number_of_regions = flash->number_of_regions;
    }

    if (!flash->number_of_regions)
    {
        ret_code = -ENOMEM;
  105420:	00bffd04 	movi	r2,-12
  105424:	f800283a 	ret
    }
    else if (flash->number_of_regions > ALT_MAX_NUMBER_OF_FLASH_REGIONS)
    {
        ret_code = -EFAULT;
  105428:	00bffc84 	movi	r2,-14
  10542c:	f800283a 	ret
    alt_flash_fd *fd,
    flash_region **info,
    int          *number_of_regions
)
{
    int ret_code = 0;
  105430:	0005883a 	mov	r2,zero
            *info = &flash->region_info[0];
        }
    }

    return ret_code;
}
  105434:	f800283a 	ret

00105438 <alt_onchip_flash_write>:
    int         full_length = length;
    int         start_offset = offset;
    alt_onchip_flash_dev* flash = (alt_onchip_flash_dev*)flash_info;

    /* Make sure the input parameters is not outside of this device's range. */
    if ((offset >= flash->dev.length) || (length > (flash->dev.length - offset)))
  105438:	20800b17 	ldw	r2,44(r4)
    alt_flash_dev *flash_info,
    int           offset,
    const void    *src_addr,
    int           length
)
{
  10543c:	defff204 	addi	sp,sp,-56
  105440:	dfc00d15 	stw	ra,52(sp)
  105444:	df000c15 	stw	fp,48(sp)
  105448:	ddc00b15 	stw	r23,44(sp)
  10544c:	dd800a15 	stw	r22,40(sp)
  105450:	dd400915 	stw	r21,36(sp)
  105454:	dd000815 	stw	r20,32(sp)
  105458:	dcc00715 	stw	r19,28(sp)
  10545c:	dc800615 	stw	r18,24(sp)
  105460:	dc400515 	stw	r17,20(sp)
  105464:	dc000415 	stw	r16,16(sp)
  105468:	d9c00215 	stw	r7,8(sp)
    int         full_length = length;
    int         start_offset = offset;
    alt_onchip_flash_dev* flash = (alt_onchip_flash_dev*)flash_info;

    /* Make sure the input parameters is not outside of this device's range. */
    if ((offset >= flash->dev.length) || (length > (flash->dev.length - offset)))
  10546c:	2880460e 	bge	r5,r2,105588 <alt_onchip_flash_write+0x150>
  105470:	1145c83a 	sub	r2,r2,r5
  105474:	2827883a 	mov	r19,r5
  105478:	11c04316 	blt	r2,r7,105588 <alt_onchip_flash_write+0x150>
  10547c:	2023883a 	mov	r17,r4
  105480:	3029883a 	mov	r20,r6
  105484:	27001004 	addi	fp,r4,64
  105488:	382d883a 	mov	r22,r7
  10548c:	2821883a 	mov	r16,r5
  105490:	d8000115 	stw	zero,4(sp)
    }

    /*
    * First and foremost which sectors are affected?
    */
    for(i=0;i<flash->dev.number_of_regions;i++)
  105494:	88800c17 	ldw	r2,48(r17)
  105498:	d8c00117 	ldw	r3,4(sp)
  10549c:	1880320e 	bge	r3,r2,105568 <alt_onchip_flash_write+0x130>
    {
        /* Is it in this erase block region?*/
        if((offset >= flash->dev.region_info[i].offset) &&
  1054a0:	e4bffd17 	ldw	r18,-12(fp)
  1054a4:	84802a16 	blt	r16,r18,105550 <alt_onchip_flash_write+0x118>
  1054a8:	e0bffe17 	ldw	r2,-8(fp)
  1054ac:	9085883a 	add	r2,r18,r2
  1054b0:	8080270e 	bge	r16,r2,105550 <alt_onchip_flash_write+0x118>
  1054b4:	002f883a 	mov	r23,zero
            (offset < (flash->dev.region_info[i].offset +
            flash->dev.region_info[i].region_size)))
        {
            current_offset = flash->dev.region_info[i].offset;

            for(j=0;j<flash->dev.region_info[i].number_of_blocks;j++)
  1054b8:	e0bfff17 	ldw	r2,-4(fp)
  1054bc:	b880240e 	bge	r23,r2,105550 <alt_onchip_flash_write+0x118>
            {
                if ((offset >= current_offset ) &&
  1054c0:	84801f16 	blt	r16,r18,105540 <alt_onchip_flash_write+0x108>
                    (offset < (current_offset +
  1054c4:	e0800017 	ldw	r2,0(fp)
  1054c8:	9085883a 	add	r2,r18,r2
        {
            current_offset = flash->dev.region_info[i].offset;

            for(j=0;j<flash->dev.region_info[i].number_of_blocks;j++)
            {
                if ((offset >= current_offset ) &&
  1054cc:	80801c0e 	bge	r16,r2,105540 <alt_onchip_flash_write+0x108>
                {
                    /*
                    * Check if the contents of the block are different
                    * from the data we wish to put there
                    */
                    data_to_write = (current_offset + flash->dev.region_info[i].block_size - offset);
  1054d0:	1405c83a 	sub	r2,r2,r16
                    data_to_write = MIN(data_to_write, length);
  1054d4:	b02b883a 	mov	r21,r22
  1054d8:	1580010e 	bge	r2,r22,1054e0 <alt_onchip_flash_write+0xa8>
  1054dc:	102b883a 	mov	r21,r2
                    if(memcmp(src_addr, (alt_u8*)flash->dev.base_addr+offset, data_to_write))
  1054e0:	89400a17 	ldw	r5,40(r17)
  1054e4:	a80d883a 	mov	r6,r21
  1054e8:	a009883a 	mov	r4,r20
  1054ec:	2c0b883a 	add	r5,r5,r16
  1054f0:	0105ed40 	call	105ed4 <memcmp>
  1054f4:	10001b26 	beq	r2,zero,105564 <alt_onchip_flash_write+0x12c>
                    {
                        ret_code = (*flash->dev.erase_block)(&flash->dev, current_offset);
  1054f8:	88800817 	ldw	r2,32(r17)
  1054fc:	900b883a 	mov	r5,r18
  105500:	8809883a 	mov	r4,r17
  105504:	103ee83a 	callr	r2

                        if (!ret_code)
  105508:	1000181e 	bne	r2,zero,10556c <alt_onchip_flash_write+0x134>
                        {
                            ret_code = (*flash->dev.write_block)(
  10550c:	dd400015 	stw	r21,0(sp)
  105510:	88800917 	ldw	r2,36(r17)
  105514:	a00f883a 	mov	r7,r20
  105518:	800d883a 	mov	r6,r16
  10551c:	900b883a 	mov	r5,r18
  105520:	8809883a 	mov	r4,r17
  105524:	103ee83a 	callr	r2
                                                                data_to_write);
                        }
                    }

                    /* Was this the last block? */
                    if ((length == data_to_write) || ret_code)
  105528:	b5401026 	beq	r22,r21,10556c <alt_onchip_flash_write+0x134>
  10552c:	10000f1e 	bne	r2,zero,10556c <alt_onchip_flash_write+0x134>
                    {
                        goto finished;
                    }

                    length -= data_to_write;
                    offset = current_offset + flash->dev.region_info[i].block_size;
  105530:	e4000017 	ldw	r16,0(fp)
                    if ((length == data_to_write) || ret_code)
                    {
                        goto finished;
                    }

                    length -= data_to_write;
  105534:	b56dc83a 	sub	r22,r22,r21
                    offset = current_offset + flash->dev.region_info[i].block_size;
                    src_addr = (alt_u8*)src_addr + data_to_write;
  105538:	a569883a 	add	r20,r20,r21
                    {
                        goto finished;
                    }

                    length -= data_to_write;
                    offset = current_offset + flash->dev.region_info[i].block_size;
  10553c:	9421883a 	add	r16,r18,r16
                    src_addr = (alt_u8*)src_addr + data_to_write;
                }
                current_offset += flash->dev.region_info[i].block_size;
  105540:	e0800017 	ldw	r2,0(fp)
            (offset < (flash->dev.region_info[i].offset +
            flash->dev.region_info[i].region_size)))
        {
            current_offset = flash->dev.region_info[i].offset;

            for(j=0;j<flash->dev.region_info[i].number_of_blocks;j++)
  105544:	bdc00044 	addi	r23,r23,1

                    length -= data_to_write;
                    offset = current_offset + flash->dev.region_info[i].block_size;
                    src_addr = (alt_u8*)src_addr + data_to_write;
                }
                current_offset += flash->dev.region_info[i].block_size;
  105548:	90a5883a 	add	r18,r18,r2
  10554c:	003fda06 	br	1054b8 <_gp+0xffff7268>
    }

    /*
    * First and foremost which sectors are affected?
    */
    for(i=0;i<flash->dev.number_of_regions;i++)
  105550:	d8c00117 	ldw	r3,4(sp)
  105554:	e7000404 	addi	fp,fp,16
  105558:	18c00044 	addi	r3,r3,1
  10555c:	d8c00115 	stw	r3,4(sp)
  105560:	003fcc06 	br	105494 <_gp+0xffff7244>
                                                                data_to_write);
                        }
                    }

                    /* Was this the last block? */
                    if ((length == data_to_write) || ret_code)
  105564:	b57ff21e 	bne	r22,r21,105530 <_gp+0xffff72e0>
    int         full_length = length;
    int         start_offset = offset;
    alt_onchip_flash_dev* flash = (alt_onchip_flash_dev*)flash_info;

    /* Make sure the input parameters is not outside of this device's range. */
    if ((offset >= flash->dev.length) || (length > (flash->dev.length - offset)))
  105568:	0005883a 	mov	r2,zero
            }
        }
    }

finished:
    alt_dcache_flush((alt_u8*)flash->dev.base_addr+start_offset, full_length);
  10556c:	89000a17 	ldw	r4,40(r17)
  105570:	d9400217 	ldw	r5,8(sp)
  105574:	d8800315 	stw	r2,12(sp)
  105578:	24c9883a 	add	r4,r4,r19
  10557c:	0105c140 	call	105c14 <alt_dcache_flush>
    return ret_code;
  105580:	d8800317 	ldw	r2,12(sp)
  105584:	00000106 	br	10558c <alt_onchip_flash_write+0x154>
    alt_onchip_flash_dev* flash = (alt_onchip_flash_dev*)flash_info;

    /* Make sure the input parameters is not outside of this device's range. */
    if ((offset >= flash->dev.length) || (length > (flash->dev.length - offset)))
    {
        return -EFAULT;
  105588:	00bffc84 	movi	r2,-14
    }

finished:
    alt_dcache_flush((alt_u8*)flash->dev.base_addr+start_offset, full_length);
    return ret_code;
}
  10558c:	dfc00d17 	ldw	ra,52(sp)
  105590:	df000c17 	ldw	fp,48(sp)
  105594:	ddc00b17 	ldw	r23,44(sp)
  105598:	dd800a17 	ldw	r22,40(sp)
  10559c:	dd400917 	ldw	r21,36(sp)
  1055a0:	dd000817 	ldw	r20,32(sp)
  1055a4:	dcc00717 	ldw	r19,28(sp)
  1055a8:	dc800617 	ldw	r18,24(sp)
  1055ac:	dc400517 	ldw	r17,20(sp)
  1055b0:	dc000417 	ldw	r16,16(sp)
  1055b4:	dec00e04 	addi	sp,sp,56
  1055b8:	f800283a 	ret

001055bc <altera_onchip_flash_init>:

    /* Set up flash_region data structures. */
    number_of_regions = 0;
    region_info = &flash->dev.region_info[0];

    if (flash->csr_base != NULL) {
  1055bc:	20802f17 	ldw	r2,188(r4)
**/
void altera_onchip_flash_init
(
    alt_onchip_flash_dev *flash
)
{
  1055c0:	defff704 	addi	sp,sp,-36
  1055c4:	dc800215 	stw	r18,8(sp)
  1055c8:	dc000015 	stw	r16,0(sp)
  1055cc:	dfc00815 	stw	ra,32(sp)
  1055d0:	ddc00715 	stw	r23,28(sp)
  1055d4:	dd800615 	stw	r22,24(sp)
  1055d8:	dd400515 	stw	r21,20(sp)
  1055dc:	dd000415 	stw	r20,16(sp)
  1055e0:	dcc00315 	stw	r19,12(sp)
  1055e4:	dc400115 	stw	r17,4(sp)
  1055e8:	2021883a 	mov	r16,r4
    int sector4_status = ALTERA_ONCHIP_FLASH_STATUS_SECTOR4_AVAILABLE;
    int sector5_status = ALTERA_ONCHIP_FLASH_STATUS_SECTOR5_AVAILABLE;

    /* Set up flash_region data structures. */
    number_of_regions = 0;
    region_info = &flash->dev.region_info[0];
  1055ec:	24800d04 	addi	r18,r4,52

    if (flash->csr_base != NULL) {
  1055f0:	10000b26 	beq	r2,zero,105620 <altera_onchip_flash_init+0x64>
        sector1_status = IORD_ALTERA_ONCHIP_FLASH_STATUS(flash->csr_base) & ALTERA_ONCHIP_FLASH_STATUS_SECTOR1_MSK;
  1055f4:	10c00037 	ldwio	r3,0(r2)
  1055f8:	18c0080c 	andi	r3,r3,32
        sector2_status = IORD_ALTERA_ONCHIP_FLASH_STATUS(flash->csr_base) & ALTERA_ONCHIP_FLASH_STATUS_SECTOR2_MSK;
  1055fc:	15800037 	ldwio	r22,0(r2)
  105600:	b580100c 	andi	r22,r22,64
        sector3_status = IORD_ALTERA_ONCHIP_FLASH_STATUS(flash->csr_base) & ALTERA_ONCHIP_FLASH_STATUS_SECTOR3_MSK;
  105604:	15000037 	ldwio	r20,0(r2)
  105608:	a500200c 	andi	r20,r20,128
        sector4_status = IORD_ALTERA_ONCHIP_FLASH_STATUS(flash->csr_base) & ALTERA_ONCHIP_FLASH_STATUS_SECTOR4_MSK;
  10560c:	14c00037 	ldwio	r19,0(r2)
  105610:	9cc0400c 	andi	r19,r19,256
        sector5_status = IORD_ALTERA_ONCHIP_FLASH_STATUS(flash->csr_base) & ALTERA_ONCHIP_FLASH_STATUS_SECTOR5_MSK;
  105614:	15400037 	ldwio	r21,0(r2)
  105618:	ad40800c 	andi	r21,r21,512
  10561c:	00000506 	br	105634 <altera_onchip_flash_init+0x78>
    flash_region* region_info;
    int sector1_status = ALTERA_ONCHIP_FLASH_STATUS_SECTOR1_AVAILABLE;
    int sector2_status = ALTERA_ONCHIP_FLASH_STATUS_SECTOR2_AVAILABLE;
    int sector3_status = ALTERA_ONCHIP_FLASH_STATUS_SECTOR3_AVAILABLE;
    int sector4_status = ALTERA_ONCHIP_FLASH_STATUS_SECTOR4_AVAILABLE;
    int sector5_status = ALTERA_ONCHIP_FLASH_STATUS_SECTOR5_AVAILABLE;
  105620:	002b883a 	mov	r21,zero
    int number_of_regions;
    flash_region* region_info;
    int sector1_status = ALTERA_ONCHIP_FLASH_STATUS_SECTOR1_AVAILABLE;
    int sector2_status = ALTERA_ONCHIP_FLASH_STATUS_SECTOR2_AVAILABLE;
    int sector3_status = ALTERA_ONCHIP_FLASH_STATUS_SECTOR3_AVAILABLE;
    int sector4_status = ALTERA_ONCHIP_FLASH_STATUS_SECTOR4_AVAILABLE;
  105624:	0027883a 	mov	r19,zero
    /* A region is a sector of the onchip flash */
    int number_of_regions;
    flash_region* region_info;
    int sector1_status = ALTERA_ONCHIP_FLASH_STATUS_SECTOR1_AVAILABLE;
    int sector2_status = ALTERA_ONCHIP_FLASH_STATUS_SECTOR2_AVAILABLE;
    int sector3_status = ALTERA_ONCHIP_FLASH_STATUS_SECTOR3_AVAILABLE;
  105628:	0029883a 	mov	r20,zero
{
    /* A region is a sector of the onchip flash */
    int number_of_regions;
    flash_region* region_info;
    int sector1_status = ALTERA_ONCHIP_FLASH_STATUS_SECTOR1_AVAILABLE;
    int sector2_status = ALTERA_ONCHIP_FLASH_STATUS_SECTOR2_AVAILABLE;
  10562c:	002d883a 	mov	r22,zero
)
{
    /* A region is a sector of the onchip flash */
    int number_of_regions;
    flash_region* region_info;
    int sector1_status = ALTERA_ONCHIP_FLASH_STATUS_SECTOR1_AVAILABLE;
  105630:	0007883a 	mov	r3,zero
        sector3_status = IORD_ALTERA_ONCHIP_FLASH_STATUS(flash->csr_base) & ALTERA_ONCHIP_FLASH_STATUS_SECTOR3_MSK;
        sector4_status = IORD_ALTERA_ONCHIP_FLASH_STATUS(flash->csr_base) & ALTERA_ONCHIP_FLASH_STATUS_SECTOR4_MSK;
        sector5_status = IORD_ALTERA_ONCHIP_FLASH_STATUS(flash->csr_base) & ALTERA_ONCHIP_FLASH_STATUS_SECTOR5_MSK;
    }

    if ((flash->sector1_enabled == 1) && (sector1_status != ALTERA_ONCHIP_FLASH_STATUS_SECTOR1_UNAVAILABLE)) {
  105634:	84403017 	ldw	r17,192(r16)
  105638:	00800044 	movi	r2,1
  10563c:	88800d1e 	bne	r17,r2,105674 <altera_onchip_flash_init+0xb8>
  105640:	18000c1e 	bne	r3,zero,105674 <altera_onchip_flash_init+0xb8>

        region_info[number_of_regions].offset = flash->sector1_start_addr;
  105644:	81003117 	ldw	r4,196(r16)
        region_info[number_of_regions].region_size = flash->sector1_end_addr - flash->sector1_start_addr + 1;
  105648:	80803217 	ldw	r2,200(r16)
        region_info[number_of_regions].number_of_blocks = flash->dev.region_info[number_of_regions].region_size / flash->page_size;
  10564c:	85c03f17 	ldw	r23,252(r16)
        sector5_status = IORD_ALTERA_ONCHIP_FLASH_STATUS(flash->csr_base) & ALTERA_ONCHIP_FLASH_STATUS_SECTOR5_MSK;
    }

    if ((flash->sector1_enabled == 1) && (sector1_status != ALTERA_ONCHIP_FLASH_STATUS_SECTOR1_UNAVAILABLE)) {

        region_info[number_of_regions].offset = flash->sector1_start_addr;
  105650:	81000d15 	stw	r4,52(r16)
        region_info[number_of_regions].region_size = flash->sector1_end_addr - flash->sector1_start_addr + 1;
  105654:	1109c83a 	sub	r4,r2,r4
  105658:	21000044 	addi	r4,r4,1
  10565c:	81000e15 	stw	r4,56(r16)
        region_info[number_of_regions].number_of_blocks = flash->dev.region_info[number_of_regions].region_size / flash->page_size;
  105660:	b80b883a 	mov	r5,r23
  105664:	010446c0 	call	10446c <__divsi3>
  105668:	80800f15 	stw	r2,60(r16)
        region_info[number_of_regions].block_size = flash->page_size;
  10566c:	85c01015 	stw	r23,64(r16)
  105670:	00000106 	br	105678 <altera_onchip_flash_init+0xbc>
    int sector3_status = ALTERA_ONCHIP_FLASH_STATUS_SECTOR3_AVAILABLE;
    int sector4_status = ALTERA_ONCHIP_FLASH_STATUS_SECTOR4_AVAILABLE;
    int sector5_status = ALTERA_ONCHIP_FLASH_STATUS_SECTOR5_AVAILABLE;

    /* Set up flash_region data structures. */
    number_of_regions = 0;
  105674:	0023883a 	mov	r17,zero
        region_info[number_of_regions].block_size = flash->page_size;

        number_of_regions++;
    }

    if ((flash->sector2_enabled == 1) && (sector2_status != ALTERA_ONCHIP_FLASH_STATUS_SECTOR2_UNAVAILABLE)) {
  105678:	80c03317 	ldw	r3,204(r16)
  10567c:	00800044 	movi	r2,1
  105680:	1880111e 	bne	r3,r2,1056c8 <altera_onchip_flash_init+0x10c>
  105684:	b000101e 	bne	r22,zero,1056c8 <altera_onchip_flash_init+0x10c>

        region_info[number_of_regions].offset = flash->sector2_start_addr;
  105688:	81003417 	ldw	r4,208(r16)
        region_info[number_of_regions].region_size = flash->sector2_end_addr - flash->sector2_start_addr + 1;
  10568c:	80803517 	ldw	r2,212(r16)
        number_of_regions++;
    }

    if ((flash->sector2_enabled == 1) && (sector2_status != ALTERA_ONCHIP_FLASH_STATUS_SECTOR2_UNAVAILABLE)) {

        region_info[number_of_regions].offset = flash->sector2_start_addr;
  105690:	8806913a 	slli	r3,r17,4
        region_info[number_of_regions].region_size = flash->sector2_end_addr - flash->sector2_start_addr + 1;
        region_info[number_of_regions].number_of_blocks = flash->dev.region_info[number_of_regions].region_size / flash->page_size;
  105694:	85c03f17 	ldw	r23,252(r16)
    }

    if ((flash->sector2_enabled == 1) && (sector2_status != ALTERA_ONCHIP_FLASH_STATUS_SECTOR2_UNAVAILABLE)) {

        region_info[number_of_regions].offset = flash->sector2_start_addr;
        region_info[number_of_regions].region_size = flash->sector2_end_addr - flash->sector2_start_addr + 1;
  105698:	1105c83a 	sub	r2,r2,r4
        number_of_regions++;
    }

    if ((flash->sector2_enabled == 1) && (sector2_status != ALTERA_ONCHIP_FLASH_STATUS_SECTOR2_UNAVAILABLE)) {

        region_info[number_of_regions].offset = flash->sector2_start_addr;
  10569c:	90ed883a 	add	r22,r18,r3
        region_info[number_of_regions].region_size = flash->sector2_end_addr - flash->sector2_start_addr + 1;
  1056a0:	10800044 	addi	r2,r2,1
  1056a4:	b0800115 	stw	r2,4(r22)
        region_info[number_of_regions].number_of_blocks = flash->dev.region_info[number_of_regions].region_size / flash->page_size;
  1056a8:	80c7883a 	add	r3,r16,r3
        number_of_regions++;
    }

    if ((flash->sector2_enabled == 1) && (sector2_status != ALTERA_ONCHIP_FLASH_STATUS_SECTOR2_UNAVAILABLE)) {

        region_info[number_of_regions].offset = flash->sector2_start_addr;
  1056ac:	b1000015 	stw	r4,0(r22)
        region_info[number_of_regions].region_size = flash->sector2_end_addr - flash->sector2_start_addr + 1;
        region_info[number_of_regions].number_of_blocks = flash->dev.region_info[number_of_regions].region_size / flash->page_size;
  1056b0:	19000e17 	ldw	r4,56(r3)
  1056b4:	b80b883a 	mov	r5,r23
        region_info[number_of_regions].block_size = flash->page_size;

        number_of_regions++;
  1056b8:	8c400044 	addi	r17,r17,1

    if ((flash->sector2_enabled == 1) && (sector2_status != ALTERA_ONCHIP_FLASH_STATUS_SECTOR2_UNAVAILABLE)) {

        region_info[number_of_regions].offset = flash->sector2_start_addr;
        region_info[number_of_regions].region_size = flash->sector2_end_addr - flash->sector2_start_addr + 1;
        region_info[number_of_regions].number_of_blocks = flash->dev.region_info[number_of_regions].region_size / flash->page_size;
  1056bc:	010446c0 	call	10446c <__divsi3>
  1056c0:	b0800215 	stw	r2,8(r22)
        region_info[number_of_regions].block_size = flash->page_size;
  1056c4:	b5c00315 	stw	r23,12(r22)

        number_of_regions++;
	}

    if ((flash->sector3_enabled == 1) && (sector3_status != ALTERA_ONCHIP_FLASH_STATUS_SECTOR3_UNAVAILABLE)) {
  1056c8:	80c03617 	ldw	r3,216(r16)
  1056cc:	00800044 	movi	r2,1
  1056d0:	1880111e 	bne	r3,r2,105718 <altera_onchip_flash_init+0x15c>
  1056d4:	a000101e 	bne	r20,zero,105718 <altera_onchip_flash_init+0x15c>

        region_info[number_of_regions].offset = flash->sector3_start_addr;
  1056d8:	81003717 	ldw	r4,220(r16)
        region_info[number_of_regions].region_size = flash->sector3_end_addr - flash->sector3_start_addr + 1;
  1056dc:	80803817 	ldw	r2,224(r16)
        number_of_regions++;
	}

    if ((flash->sector3_enabled == 1) && (sector3_status != ALTERA_ONCHIP_FLASH_STATUS_SECTOR3_UNAVAILABLE)) {

        region_info[number_of_regions].offset = flash->sector3_start_addr;
  1056e0:	8806913a 	slli	r3,r17,4
        region_info[number_of_regions].region_size = flash->sector3_end_addr - flash->sector3_start_addr + 1;
        region_info[number_of_regions].number_of_blocks = flash->dev.region_info[number_of_regions].region_size / flash->page_size;
  1056e4:	85803f17 	ldw	r22,252(r16)
	}

    if ((flash->sector3_enabled == 1) && (sector3_status != ALTERA_ONCHIP_FLASH_STATUS_SECTOR3_UNAVAILABLE)) {

        region_info[number_of_regions].offset = flash->sector3_start_addr;
        region_info[number_of_regions].region_size = flash->sector3_end_addr - flash->sector3_start_addr + 1;
  1056e8:	1105c83a 	sub	r2,r2,r4
        number_of_regions++;
	}

    if ((flash->sector3_enabled == 1) && (sector3_status != ALTERA_ONCHIP_FLASH_STATUS_SECTOR3_UNAVAILABLE)) {

        region_info[number_of_regions].offset = flash->sector3_start_addr;
  1056ec:	90e9883a 	add	r20,r18,r3
        region_info[number_of_regions].region_size = flash->sector3_end_addr - flash->sector3_start_addr + 1;
  1056f0:	10800044 	addi	r2,r2,1
  1056f4:	a0800115 	stw	r2,4(r20)
        region_info[number_of_regions].number_of_blocks = flash->dev.region_info[number_of_regions].region_size / flash->page_size;
  1056f8:	80c7883a 	add	r3,r16,r3
        number_of_regions++;
	}

    if ((flash->sector3_enabled == 1) && (sector3_status != ALTERA_ONCHIP_FLASH_STATUS_SECTOR3_UNAVAILABLE)) {

        region_info[number_of_regions].offset = flash->sector3_start_addr;
  1056fc:	a1000015 	stw	r4,0(r20)
        region_info[number_of_regions].region_size = flash->sector3_end_addr - flash->sector3_start_addr + 1;
        region_info[number_of_regions].number_of_blocks = flash->dev.region_info[number_of_regions].region_size / flash->page_size;
  105700:	19000e17 	ldw	r4,56(r3)
  105704:	b00b883a 	mov	r5,r22
        region_info[number_of_regions].block_size = flash->page_size;

        number_of_regions++;
  105708:	8c400044 	addi	r17,r17,1

    if ((flash->sector3_enabled == 1) && (sector3_status != ALTERA_ONCHIP_FLASH_STATUS_SECTOR3_UNAVAILABLE)) {

        region_info[number_of_regions].offset = flash->sector3_start_addr;
        region_info[number_of_regions].region_size = flash->sector3_end_addr - flash->sector3_start_addr + 1;
        region_info[number_of_regions].number_of_blocks = flash->dev.region_info[number_of_regions].region_size / flash->page_size;
  10570c:	010446c0 	call	10446c <__divsi3>
  105710:	a0800215 	stw	r2,8(r20)
        region_info[number_of_regions].block_size = flash->page_size;
  105714:	a5800315 	stw	r22,12(r20)

        number_of_regions++;
	}

	if ((flash->sector4_enabled == 1) && (sector4_status != ALTERA_ONCHIP_FLASH_STATUS_SECTOR4_UNAVAILABLE)) {
  105718:	80c03917 	ldw	r3,228(r16)
  10571c:	00800044 	movi	r2,1
  105720:	1880111e 	bne	r3,r2,105768 <altera_onchip_flash_init+0x1ac>
  105724:	9800101e 	bne	r19,zero,105768 <altera_onchip_flash_init+0x1ac>

        region_info[number_of_regions].offset = flash->sector4_start_addr;
  105728:	81003a17 	ldw	r4,232(r16)
        region_info[number_of_regions].region_size = flash->sector4_end_addr - flash->sector4_start_addr + 1;
  10572c:	80803b17 	ldw	r2,236(r16)
        number_of_regions++;
	}

	if ((flash->sector4_enabled == 1) && (sector4_status != ALTERA_ONCHIP_FLASH_STATUS_SECTOR4_UNAVAILABLE)) {

        region_info[number_of_regions].offset = flash->sector4_start_addr;
  105730:	8806913a 	slli	r3,r17,4
        region_info[number_of_regions].region_size = flash->sector4_end_addr - flash->sector4_start_addr + 1;
        region_info[number_of_regions].number_of_blocks = flash->dev.region_info[number_of_regions].region_size / flash->page_size;
  105734:	85003f17 	ldw	r20,252(r16)
	}

	if ((flash->sector4_enabled == 1) && (sector4_status != ALTERA_ONCHIP_FLASH_STATUS_SECTOR4_UNAVAILABLE)) {

        region_info[number_of_regions].offset = flash->sector4_start_addr;
        region_info[number_of_regions].region_size = flash->sector4_end_addr - flash->sector4_start_addr + 1;
  105738:	1105c83a 	sub	r2,r2,r4
        number_of_regions++;
	}

	if ((flash->sector4_enabled == 1) && (sector4_status != ALTERA_ONCHIP_FLASH_STATUS_SECTOR4_UNAVAILABLE)) {

        region_info[number_of_regions].offset = flash->sector4_start_addr;
  10573c:	90e7883a 	add	r19,r18,r3
        region_info[number_of_regions].region_size = flash->sector4_end_addr - flash->sector4_start_addr + 1;
  105740:	10800044 	addi	r2,r2,1
  105744:	98800115 	stw	r2,4(r19)
        region_info[number_of_regions].number_of_blocks = flash->dev.region_info[number_of_regions].region_size / flash->page_size;
  105748:	80c7883a 	add	r3,r16,r3
        number_of_regions++;
	}

	if ((flash->sector4_enabled == 1) && (sector4_status != ALTERA_ONCHIP_FLASH_STATUS_SECTOR4_UNAVAILABLE)) {

        region_info[number_of_regions].offset = flash->sector4_start_addr;
  10574c:	99000015 	stw	r4,0(r19)
        region_info[number_of_regions].region_size = flash->sector4_end_addr - flash->sector4_start_addr + 1;
        region_info[number_of_regions].number_of_blocks = flash->dev.region_info[number_of_regions].region_size / flash->page_size;
  105750:	19000e17 	ldw	r4,56(r3)
  105754:	a00b883a 	mov	r5,r20
        region_info[number_of_regions].block_size = flash->page_size;

        number_of_regions++;
  105758:	8c400044 	addi	r17,r17,1

	if ((flash->sector4_enabled == 1) && (sector4_status != ALTERA_ONCHIP_FLASH_STATUS_SECTOR4_UNAVAILABLE)) {

        region_info[number_of_regions].offset = flash->sector4_start_addr;
        region_info[number_of_regions].region_size = flash->sector4_end_addr - flash->sector4_start_addr + 1;
        region_info[number_of_regions].number_of_blocks = flash->dev.region_info[number_of_regions].region_size / flash->page_size;
  10575c:	010446c0 	call	10446c <__divsi3>
  105760:	98800215 	stw	r2,8(r19)
        region_info[number_of_regions].block_size = flash->page_size;
  105764:	9d000315 	stw	r20,12(r19)

        number_of_regions++;
	}

    if ((flash->sector5_enabled == 1) && (sector5_status != ALTERA_ONCHIP_FLASH_STATUS_SECTOR5_UNAVAILABLE)) {
  105768:	80c03c17 	ldw	r3,240(r16)
  10576c:	00800044 	movi	r2,1
  105770:	1880111e 	bne	r3,r2,1057b8 <altera_onchip_flash_init+0x1fc>
  105774:	a800101e 	bne	r21,zero,1057b8 <altera_onchip_flash_init+0x1fc>

        region_info[number_of_regions].offset = flash->sector5_start_addr;
  105778:	81003d17 	ldw	r4,244(r16)
        region_info[number_of_regions].region_size = flash->sector5_end_addr - flash->sector5_start_addr + 1;
  10577c:	80803e17 	ldw	r2,248(r16)
        number_of_regions++;
	}

    if ((flash->sector5_enabled == 1) && (sector5_status != ALTERA_ONCHIP_FLASH_STATUS_SECTOR5_UNAVAILABLE)) {

        region_info[number_of_regions].offset = flash->sector5_start_addr;
  105780:	8806913a 	slli	r3,r17,4
        region_info[number_of_regions].region_size = flash->sector5_end_addr - flash->sector5_start_addr + 1;
        region_info[number_of_regions].number_of_blocks = flash->dev.region_info[number_of_regions].region_size / flash->page_size;
  105784:	84c03f17 	ldw	r19,252(r16)
	}

    if ((flash->sector5_enabled == 1) && (sector5_status != ALTERA_ONCHIP_FLASH_STATUS_SECTOR5_UNAVAILABLE)) {

        region_info[number_of_regions].offset = flash->sector5_start_addr;
        region_info[number_of_regions].region_size = flash->sector5_end_addr - flash->sector5_start_addr + 1;
  105788:	1105c83a 	sub	r2,r2,r4
        number_of_regions++;
	}

    if ((flash->sector5_enabled == 1) && (sector5_status != ALTERA_ONCHIP_FLASH_STATUS_SECTOR5_UNAVAILABLE)) {

        region_info[number_of_regions].offset = flash->sector5_start_addr;
  10578c:	90e5883a 	add	r18,r18,r3
        region_info[number_of_regions].region_size = flash->sector5_end_addr - flash->sector5_start_addr + 1;
  105790:	10800044 	addi	r2,r2,1
  105794:	90800115 	stw	r2,4(r18)
        region_info[number_of_regions].number_of_blocks = flash->dev.region_info[number_of_regions].region_size / flash->page_size;
  105798:	80c7883a 	add	r3,r16,r3
        number_of_regions++;
	}

    if ((flash->sector5_enabled == 1) && (sector5_status != ALTERA_ONCHIP_FLASH_STATUS_SECTOR5_UNAVAILABLE)) {

        region_info[number_of_regions].offset = flash->sector5_start_addr;
  10579c:	91000015 	stw	r4,0(r18)
        region_info[number_of_regions].region_size = flash->sector5_end_addr - flash->sector5_start_addr + 1;
        region_info[number_of_regions].number_of_blocks = flash->dev.region_info[number_of_regions].region_size / flash->page_size;
  1057a0:	19000e17 	ldw	r4,56(r3)
  1057a4:	980b883a 	mov	r5,r19
        region_info[number_of_regions].block_size = flash->page_size;

        number_of_regions++;
  1057a8:	8c400044 	addi	r17,r17,1

    if ((flash->sector5_enabled == 1) && (sector5_status != ALTERA_ONCHIP_FLASH_STATUS_SECTOR5_UNAVAILABLE)) {

        region_info[number_of_regions].offset = flash->sector5_start_addr;
        region_info[number_of_regions].region_size = flash->sector5_end_addr - flash->sector5_start_addr + 1;
        region_info[number_of_regions].number_of_blocks = flash->dev.region_info[number_of_regions].region_size / flash->page_size;
  1057ac:	010446c0 	call	10446c <__divsi3>
  1057b0:	90800215 	stw	r2,8(r18)
        region_info[number_of_regions].block_size = flash->page_size;
  1057b4:	94c00315 	stw	r19,12(r18)

static ALT_INLINE int alt_flash_device_register( alt_flash_fd* fd)
{
  extern alt_llist alt_flash_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) fd, &alt_flash_dev_list);
  1057b8:	d1600804 	addi	r5,gp,-32736
  1057bc:	8009883a 	mov	r4,r16

        number_of_regions++;
    }

    /* Update number of regions. */
    flash->dev.number_of_regions = number_of_regions;
  1057c0:	84400c15 	stw	r17,48(r16)

    /*
    *  Register this device as a valid flash device type
    */
    alt_flash_device_register(&(flash->dev));
}
  1057c4:	dfc00817 	ldw	ra,32(sp)
  1057c8:	ddc00717 	ldw	r23,28(sp)
  1057cc:	dd800617 	ldw	r22,24(sp)
  1057d0:	dd400517 	ldw	r21,20(sp)
  1057d4:	dd000417 	ldw	r20,16(sp)
  1057d8:	dcc00317 	ldw	r19,12(sp)
  1057dc:	dc800217 	ldw	r18,8(sp)
  1057e0:	dc400117 	ldw	r17,4(sp)
  1057e4:	dc000017 	ldw	r16,0(sp)
  1057e8:	dec00904 	addi	sp,sp,36
  1057ec:	0105c1c1 	jmpi	105c1c <alt_dev_llist_insert>

001057f0 <alt_onchip_flash_poll_for_status_to_go_idle>:
**/
int alt_onchip_flash_poll_for_status_to_go_idle
(
    alt_onchip_flash_dev *flash
)
{
  1057f0:	defffd04 	addi	sp,sp,-12
  1057f4:	dc000015 	stw	r16,0(sp)
    int ret_code = 0;
    int timeout = ALTERA_ONCHIP_FLASH_STATUS_BIT_POLLING_TIMEOUT_VALUE;
    int count_down = ALTERA_ONCHIP_FLASH_STATUS_BIT_POLLING_TIMEOUT_VALUE;

    while (
  1057f8:	040002f4 	movhi	r16,11
**/
int alt_onchip_flash_poll_for_status_to_go_idle
(
    alt_onchip_flash_dev *flash
)
{
  1057fc:	dc400115 	stw	r17,4(sp)
  105800:	dfc00215 	stw	ra,8(sp)
  105804:	2023883a 	mov	r17,r4
    int ret_code = 0;
    int timeout = ALTERA_ONCHIP_FLASH_STATUS_BIT_POLLING_TIMEOUT_VALUE;
    int count_down = ALTERA_ONCHIP_FLASH_STATUS_BIT_POLLING_TIMEOUT_VALUE;

    while (
  105808:	842b9804 	addi	r16,r16,-20896
        (IORD_ALTERA_ONCHIP_FLASH_STATUS(flash->csr_base) &
  10580c:	88802f17 	ldw	r2,188(r17)
  105810:	10800037 	ldwio	r2,0(r2)
{
    int ret_code = 0;
    int timeout = ALTERA_ONCHIP_FLASH_STATUS_BIT_POLLING_TIMEOUT_VALUE;
    int count_down = ALTERA_ONCHIP_FLASH_STATUS_BIT_POLLING_TIMEOUT_VALUE;

    while (
  105814:	108000cc 	andi	r2,r2,3
  105818:	10000526 	beq	r2,zero,105830 <alt_onchip_flash_poll_for_status_to_go_idle+0x40>
        (IORD_ALTERA_ONCHIP_FLASH_STATUS(flash->csr_base) &
              ALTERA_ONCHIP_FLASH_STATUS_BUSY_MSK
        ) !=  ALTERA_ONCHIP_FLASH_STATUS_BUSY_IDLE
    ) {
	 
	alt_busy_sleep(1); /* delay 1us */
  10581c:	01000044 	movi	r4,1
  105820:	843fffc4 	addi	r16,r16,-1
  105824:	0105b9c0 	call	105b9c <alt_busy_sleep>

        /* If timeout value is zero, it will never timeout. */
        if (timeout != 0) {
            count_down--;
            if (count_down == 0) {
  105828:	803ff81e 	bne	r16,zero,10580c <_gp+0xffff75bc>
                /* Timeout */
                ret_code = -ETIMEDOUT;
  10582c:	00bfe304 	movi	r2,-116
            }
        }
    }

    return ret_code;
}
  105830:	dfc00217 	ldw	ra,8(sp)
  105834:	dc400117 	ldw	r17,4(sp)
  105838:	dc000017 	ldw	r16,0(sp)
  10583c:	dec00304 	addi	sp,sp,12
  105840:	f800283a 	ret

00105844 <alt_onchip_flash_poll_for_status_erase_passed>:
**/
int alt_onchip_flash_poll_for_status_erase_passed
(
    alt_onchip_flash_dev *flash
)
{
  105844:	defffd04 	addi	sp,sp,-12
  105848:	dc000015 	stw	r16,0(sp)
    int ret_code = 0;
    int timeout = ALTERA_ONCHIP_FLASH_STATUS_BIT_POLLING_TIMEOUT_VALUE;
    int count_down = ALTERA_ONCHIP_FLASH_STATUS_BIT_POLLING_TIMEOUT_VALUE;

    while (
  10584c:	040002f4 	movhi	r16,11
**/
int alt_onchip_flash_poll_for_status_erase_passed
(
    alt_onchip_flash_dev *flash
)
{
  105850:	dc400115 	stw	r17,4(sp)
  105854:	dfc00215 	stw	ra,8(sp)
  105858:	2023883a 	mov	r17,r4
    int ret_code = 0;
    int timeout = ALTERA_ONCHIP_FLASH_STATUS_BIT_POLLING_TIMEOUT_VALUE;
    int count_down = ALTERA_ONCHIP_FLASH_STATUS_BIT_POLLING_TIMEOUT_VALUE;

    while (
  10585c:	842b9804 	addi	r16,r16,-20896
        (IORD_ALTERA_ONCHIP_FLASH_STATUS(flash->csr_base) &
  105860:	88802f17 	ldw	r2,188(r17)
  105864:	10800037 	ldwio	r2,0(r2)
{
    int ret_code = 0;
    int timeout = ALTERA_ONCHIP_FLASH_STATUS_BIT_POLLING_TIMEOUT_VALUE;
    int count_down = ALTERA_ONCHIP_FLASH_STATUS_BIT_POLLING_TIMEOUT_VALUE;

    while (
  105868:	1080040c 	andi	r2,r2,16
  10586c:	1000061e 	bne	r2,zero,105888 <alt_onchip_flash_poll_for_status_erase_passed+0x44>
        (IORD_ALTERA_ONCHIP_FLASH_STATUS(flash->csr_base) &
              ALTERA_ONCHIP_FLASH_STATUS_ERASE_MSK
        ) !=  ALTERA_ONCHIP_FLASH_STATUS_ERASE_PASSED
    ) {

	alt_busy_sleep(1); /* delay 1us */
  105870:	01000044 	movi	r4,1
  105874:	843fffc4 	addi	r16,r16,-1
  105878:	0105b9c0 	call	105b9c <alt_busy_sleep>

        /* If timeout value is zero, it will never timeout. */
        if (timeout != 0) {
            count_down--;
            if (count_down == 0) {
  10587c:	803ff81e 	bne	r16,zero,105860 <_gp+0xffff7610>
                /* Timeout */
                ret_code = -ETIMEDOUT;
  105880:	00bfe304 	movi	r2,-116
  105884:	00000106 	br	10588c <alt_onchip_flash_poll_for_status_erase_passed+0x48>
int alt_onchip_flash_poll_for_status_erase_passed
(
    alt_onchip_flash_dev *flash
)
{
    int ret_code = 0;
  105888:	0005883a 	mov	r2,zero
            }
        }
    }

    return ret_code;
}
  10588c:	dfc00217 	ldw	ra,8(sp)
  105890:	dc400117 	ldw	r17,4(sp)
  105894:	dc000017 	ldw	r16,0(sp)
  105898:	dec00304 	addi	sp,sp,12
  10589c:	f800283a 	ret

001058a0 <alt_onchip_flash_erase_block>:
    int ret_code = 0;
    alt_onchip_flash_dev *flash = (alt_onchip_flash_dev*)flash_info;
    int page_address;

    /* Make sure the input parameters is not outside of this device's range. */
    if (block_offset >= flash->dev.length) {
  1058a0:	20800b17 	ldw	r2,44(r4)
  1058a4:	28802f0e 	bge	r5,r2,105964 <alt_onchip_flash_erase_block+0xc4>
        return -EFAULT;
    }

    /* Make sure IP support write and erase operation */
    if ((flash->csr_base == NULL) || (flash->is_read_only)) {
  1058a8:	20802f17 	ldw	r2,188(r4)
int alt_onchip_flash_erase_block
(
    alt_flash_dev *flash_info,
    int           block_offset
)
{
  1058ac:	defffd04 	addi	sp,sp,-12
  1058b0:	dc400115 	stw	r17,4(sp)
  1058b4:	dfc00215 	stw	ra,8(sp)
  1058b8:	dc000015 	stw	r16,0(sp)
  1058bc:	2023883a 	mov	r17,r4
    if (block_offset >= flash->dev.length) {
        return -EFAULT;
    }

    /* Make sure IP support write and erase operation */
    if ((flash->csr_base == NULL) || (flash->is_read_only)) {
  1058c0:	10002a26 	beq	r2,zero,10596c <alt_onchip_flash_erase_block+0xcc>
  1058c4:	20802e17 	ldw	r2,184(r4)
  1058c8:	1000281e 	bne	r2,zero,10596c <alt_onchip_flash_erase_block+0xcc>
        return -ENODEV;
    }

    /* The block_offset must be page size aligned */
    if ((block_offset & (flash->page_size - 1)) != 0)
  1058cc:	20803f17 	ldw	r2,252(r4)
  1058d0:	10bfffc4 	addi	r2,r2,-1
  1058d4:	1144703a 	and	r2,r2,r5
  1058d8:	1000261e 	bne	r2,zero,105974 <alt_onchip_flash_erase_block+0xd4>
  1058dc:	2821883a 	mov	r16,r5
        /* The address is not aligned */
        return -EINVAL;
    }

    /* Wait until flash controller idle */
    ret_code = alt_onchip_flash_poll_for_status_to_go_idle(flash);
  1058e0:	01057f00 	call	1057f0 <alt_onchip_flash_poll_for_status_to_go_idle>
    if (ret_code != 0)
  1058e4:	1000241e 	bne	r2,zero,105978 <alt_onchip_flash_erase_block+0xd8>
    {
        return ret_code;
    }

    /* Enable write and erase operation */
    ALTERA_ONCHIP_FLASH_ENABLE_WRITE_AND_ERASE_OPERATION(flash->csr_base);
  1058e8:	88802f17 	ldw	r2,188(r17)
  1058ec:	10800104 	addi	r2,r2,4
  1058f0:	10c00037 	ldwio	r3,0(r2)
  1058f4:	193c002c 	andhi	r4,r3,61440
  1058f8:	00c02034 	movhi	r3,128
  1058fc:	18ffffc4 	addi	r3,r3,-1
  105900:	20c6b03a 	or	r3,r4,r3
  105904:	10c00035 	stwio	r3,0(r2)

    /* Calculate Page erase address, it is 32bit word addressing*/
    page_address = block_offset / 4;

    /* Perform Page erase operation */
    ALTERA_ONCHIP_FLASH_PAGE_ERASE(flash->csr_base, page_address);
  105908:	88c02f17 	ldw	r3,188(r17)
  10590c:	18c00104 	addi	r3,r3,4
  105910:	18800037 	ldwio	r2,0(r3)
  105914:	800b883a 	mov	r5,r16
  105918:	8000010e 	bge	r16,zero,105920 <alt_onchip_flash_erase_block+0x80>
  10591c:	814000c4 	addi	r5,r16,3
  105920:	280bd0ba 	srai	r5,r5,2
  105924:	10bc002c 	andhi	r2,r2,61440
  105928:	29401c34 	orhi	r5,r5,112
  10592c:	288ab03a 	or	r5,r5,r2
  105930:	19400035 	stwio	r5,0(r3)

    /* Wait until flash controller idle */
    ret_code = alt_onchip_flash_poll_for_status_to_go_idle(flash);
  105934:	8809883a 	mov	r4,r17
  105938:	01057f00 	call	1057f0 <alt_onchip_flash_poll_for_status_to_go_idle>

    /* Wait until flash controller indicate erase passed */
    ret_code = alt_onchip_flash_poll_for_status_erase_passed(flash);
  10593c:	8809883a 	mov	r4,r17
  105940:	01058440 	call	105844 <alt_onchip_flash_poll_for_status_erase_passed>

    /* Disable write and erase operation */
    ALTERA_ONCHIP_FLASH_DISABLE_WRITE_AND_ERASE_OPERATION(flash->csr_base);
  105944:	88c02f17 	ldw	r3,188(r17)
  105948:	18c00104 	addi	r3,r3,4
  10594c:	19400037 	ldwio	r5,0(r3)
  105950:	01040034 	movhi	r4,4096
  105954:	213fffc4 	addi	r4,r4,-1
  105958:	2908b03a 	or	r4,r5,r4
  10595c:	19000035 	stwio	r4,0(r3)

    return ret_code;
  105960:	00000506 	br	105978 <alt_onchip_flash_erase_block+0xd8>
    alt_onchip_flash_dev *flash = (alt_onchip_flash_dev*)flash_info;
    int page_address;

    /* Make sure the input parameters is not outside of this device's range. */
    if (block_offset >= flash->dev.length) {
        return -EFAULT;
  105964:	00bffc84 	movi	r2,-14

    /* Disable write and erase operation */
    ALTERA_ONCHIP_FLASH_DISABLE_WRITE_AND_ERASE_OPERATION(flash->csr_base);

    return ret_code;
}
  105968:	f800283a 	ret
        return -EFAULT;
    }

    /* Make sure IP support write and erase operation */
    if ((flash->csr_base == NULL) || (flash->is_read_only)) {
        return -ENODEV;
  10596c:	00bffb44 	movi	r2,-19
  105970:	00000106 	br	105978 <alt_onchip_flash_erase_block+0xd8>

    /* The block_offset must be page size aligned */
    if ((block_offset & (flash->page_size - 1)) != 0)
    {
        /* The address is not aligned */
        return -EINVAL;
  105974:	00bffa84 	movi	r2,-22

    /* Disable write and erase operation */
    ALTERA_ONCHIP_FLASH_DISABLE_WRITE_AND_ERASE_OPERATION(flash->csr_base);

    return ret_code;
}
  105978:	dfc00217 	ldw	ra,8(sp)
  10597c:	dc400117 	ldw	r17,4(sp)
  105980:	dc000017 	ldw	r16,0(sp)
  105984:	dec00304 	addi	sp,sp,12
  105988:	f800283a 	ret

0010598c <alt_onchip_flash_poll_for_status_write_passed>:
**/
int alt_onchip_flash_poll_for_status_write_passed
(
    alt_onchip_flash_dev *flash
)
{
  10598c:	defffd04 	addi	sp,sp,-12
  105990:	dc000015 	stw	r16,0(sp)
    int ret_code = 0;
    int timeout = ALTERA_ONCHIP_FLASH_STATUS_BIT_POLLING_TIMEOUT_VALUE;
    int count_down = ALTERA_ONCHIP_FLASH_STATUS_BIT_POLLING_TIMEOUT_VALUE;

    while (
  105994:	040002f4 	movhi	r16,11
**/
int alt_onchip_flash_poll_for_status_write_passed
(
    alt_onchip_flash_dev *flash
)
{
  105998:	dc400115 	stw	r17,4(sp)
  10599c:	dfc00215 	stw	ra,8(sp)
  1059a0:	2023883a 	mov	r17,r4
    int ret_code = 0;
    int timeout = ALTERA_ONCHIP_FLASH_STATUS_BIT_POLLING_TIMEOUT_VALUE;
    int count_down = ALTERA_ONCHIP_FLASH_STATUS_BIT_POLLING_TIMEOUT_VALUE;

    while (
  1059a4:	842b9804 	addi	r16,r16,-20896
        (IORD_ALTERA_ONCHIP_FLASH_STATUS(flash->csr_base) &
  1059a8:	88802f17 	ldw	r2,188(r17)
  1059ac:	10800037 	ldwio	r2,0(r2)
{
    int ret_code = 0;
    int timeout = ALTERA_ONCHIP_FLASH_STATUS_BIT_POLLING_TIMEOUT_VALUE;
    int count_down = ALTERA_ONCHIP_FLASH_STATUS_BIT_POLLING_TIMEOUT_VALUE;

    while (
  1059b0:	1080020c 	andi	r2,r2,8
  1059b4:	1000061e 	bne	r2,zero,1059d0 <alt_onchip_flash_poll_for_status_write_passed+0x44>
        (IORD_ALTERA_ONCHIP_FLASH_STATUS(flash->csr_base) &
              ALTERA_ONCHIP_FLASH_STATUS_WRITE_MSK
        ) !=  ALTERA_ONCHIP_FLASH_STATUS_WRITE_PASSED
    ) {

	alt_busy_sleep(1); /* delay 1us */
  1059b8:	01000044 	movi	r4,1
  1059bc:	843fffc4 	addi	r16,r16,-1
  1059c0:	0105b9c0 	call	105b9c <alt_busy_sleep>

        /* If timeout value is zero, it will never timeout. */
        if (timeout != 0) {
            count_down--;
            if (count_down == 0) {
  1059c4:	803ff81e 	bne	r16,zero,1059a8 <_gp+0xffff7758>
                /* Timeout */
                ret_code = -ETIMEDOUT;
  1059c8:	00bfe304 	movi	r2,-116
  1059cc:	00000106 	br	1059d4 <alt_onchip_flash_poll_for_status_write_passed+0x48>
int alt_onchip_flash_poll_for_status_write_passed
(
    alt_onchip_flash_dev *flash
)
{
    int ret_code = 0;
  1059d0:	0005883a 	mov	r2,zero
            }
        }
    }

    return ret_code;
}
  1059d4:	dfc00217 	ldw	ra,8(sp)
  1059d8:	dc400117 	ldw	r17,4(sp)
  1059dc:	dc000017 	ldw	r16,0(sp)
  1059e0:	dec00304 	addi	sp,sp,12
  1059e4:	f800283a 	ret

001059e8 <alt_onchip_flash_write_block>:
    int next_data_offset;
    alt_u32 chunk_of_data;

    /* Make sure the input parameters is not outside of this device's range. */
    if (
        (block_offset >= flash->dev.length) ||
  1059e8:	20800b17 	ldw	r2,44(r4)
    int           block_offset,
    int           data_offset,
    const void    *data,
    int           length
)
{
  1059ec:	defff404 	addi	sp,sp,-48
  1059f0:	dc800415 	stw	r18,16(sp)
  1059f4:	dfc00b15 	stw	ra,44(sp)
  1059f8:	df000a15 	stw	fp,40(sp)
  1059fc:	ddc00915 	stw	r23,36(sp)
  105a00:	dd800815 	stw	r22,32(sp)
  105a04:	dd400715 	stw	r21,28(sp)
  105a08:	dd000615 	stw	r20,24(sp)
  105a0c:	dcc00515 	stw	r19,20(sp)
  105a10:	dc400315 	stw	r17,12(sp)
  105a14:	dc000215 	stw	r16,8(sp)
  105a18:	dc800c17 	ldw	r18,48(sp)
    int current_data_offset = data_offset;
    int next_data_offset;
    alt_u32 chunk_of_data;

    /* Make sure the input parameters is not outside of this device's range. */
    if (
  105a1c:	28804e0e 	bge	r5,r2,105b58 <alt_onchip_flash_write_block+0x170>
  105a20:	3023883a 	mov	r17,r6
        (block_offset >= flash->dev.length) ||
  105a24:	30804c0e 	bge	r6,r2,105b58 <alt_onchip_flash_write_block+0x170>
        (data_offset >= flash->dev.length) ||
  105a28:	1185c83a 	sub	r2,r2,r6
  105a2c:	14804a16 	blt	r2,r18,105b58 <alt_onchip_flash_write_block+0x170>
    ) {
        return -EFAULT;
    }

    /* Make sure IP support support write and erase operation */
    if ((flash->csr_base == NULL) || (flash->is_read_only != 0)) {
  105a30:	20802f17 	ldw	r2,188(r4)
  105a34:	2027883a 	mov	r19,r4
  105a38:	10004926 	beq	r2,zero,105b60 <alt_onchip_flash_write_block+0x178>
  105a3c:	20802e17 	ldw	r2,184(r4)
  105a40:	1000471e 	bne	r2,zero,105b60 <alt_onchip_flash_write_block+0x178>
  105a44:	382f883a 	mov	r23,r7
        return -ENODEV;
    }

    /* Wait until flash controller idle */
    ret_code = alt_onchip_flash_poll_for_status_to_go_idle(flash);
  105a48:	01057f00 	call	1057f0 <alt_onchip_flash_poll_for_status_to_go_idle>
  105a4c:	1021883a 	mov	r16,r2
    if (ret_code != 0)
  105a50:	1000451e 	bne	r2,zero,105b68 <alt_onchip_flash_write_block+0x180>
    {
        return ret_code;
    }

    /* Enable write and erase operation */
    ALTERA_ONCHIP_FLASH_ENABLE_WRITE_AND_ERASE_OPERATION(flash->csr_base);
  105a54:	98802f17 	ldw	r2,188(r19)
  105a58:	10800104 	addi	r2,r2,4
  105a5c:	10c00037 	ldwio	r3,0(r2)
  105a60:	193c002c 	andhi	r4,r3,61440
  105a64:	00c02034 	movhi	r3,128
  105a68:	18ffffc4 	addi	r3,r3,-1
  105a6c:	20c6b03a 	or	r3,r4,r3
  105a70:	10c00035 	stwio	r3,0(r2)
    int           length
)
{
    int ret_code = 0;
    alt_onchip_flash_dev *flash = (alt_onchip_flash_dev*)flash_info;
    int buffer_offset = 0;
  105a74:	002b883a 	mov	r21,zero

    /* Check data length */
    while (length)
    {
        /* Minimum write size to onchip flash is 32 bits of data */
        chunk_of_data = 0xFFFFFFFF;
  105a78:	073fffc4 	movi	fp,-1
  105a7c:	05bfff04 	movi	r22,-4

    /* Enable write and erase operation */
    ALTERA_ONCHIP_FLASH_ENABLE_WRITE_AND_ERASE_OPERATION(flash->csr_base);

    /* Check data length */
    while (length)
  105a80:	90002d26 	beq	r18,zero,105b38 <alt_onchip_flash_write_block+0x150>
    {
        /* Minimum write size to onchip flash is 32 bits of data */
        chunk_of_data = 0xFFFFFFFF;
  105a84:	df000015 	stw	fp,0(sp)

        /* The start of data_offset must be 4 bytes (32 bits) aligned */
        if ((current_data_offset & (ALTERA_ONCHIP_FLASH_DATA_ALIGN_SIZE - 1)) == 0)
  105a88:	890000cc 	andi	r4,r17,3
  105a8c:	bd4b883a 	add	r5,r23,r21
  105a90:	20000f1e 	bne	r4,zero,105ad0 <alt_onchip_flash_write_block+0xe8>
        {
            /* The address is 4-byte aligned here */
            next_data_offset = (current_data_offset + ALTERA_ONCHIP_FLASH_DATA_ALIGN_SIZE) & ~(ALTERA_ONCHIP_FLASH_DATA_ALIGN_SIZE - 1);
  105a94:	89c00104 	addi	r7,r17,4
  105a98:	3d8e703a 	and	r7,r7,r22
            length_of_current_write = MIN(length, next_data_offset - current_data_offset);
  105a9c:	3c69c83a 	sub	r20,r7,r17
  105aa0:	9500010e 	bge	r18,r20,105aa8 <alt_onchip_flash_write_block+0xc0>
  105aa4:	9029883a 	mov	r20,r18
            /* Prepare the 4 bytes chunk of data to be written */
            memcpy(&chunk_of_data, &((alt_u8*)data)[buffer_offset], length_of_current_write);
  105aa8:	a00d883a 	mov	r6,r20
  105aac:	d809883a 	mov	r4,sp
  105ab0:	d9c00115 	stw	r7,4(sp)
  105ab4:	0105f040 	call	105f04 <memcpy>

        /* The start of data_offset must be 4 bytes (32 bits) aligned */
        if ((current_data_offset & (ALTERA_ONCHIP_FLASH_DATA_ALIGN_SIZE - 1)) == 0)
        {
            /* The address is 4-byte aligned here */
            next_data_offset = (current_data_offset + ALTERA_ONCHIP_FLASH_DATA_ALIGN_SIZE) & ~(ALTERA_ONCHIP_FLASH_DATA_ALIGN_SIZE - 1);
  105ab8:	d9c00117 	ldw	r7,4(sp)
  105abc:	8807883a 	mov	r3,r17
            length_of_current_write = MIN(length, next_data_offset - current_data_offset);
            /* Prepare the 4 bytes chunk of data to be written */
            memcpy(&chunk_of_data, &((alt_u8*)data)[buffer_offset], length_of_current_write);
            buffer_offset += length_of_current_write;
  105ac0:	ad2b883a 	add	r21,r21,r20
            length -= length_of_current_write;
  105ac4:	9525c83a 	sub	r18,r18,r20

        /* The start of data_offset must be 4 bytes (32 bits) aligned */
        if ((current_data_offset & (ALTERA_ONCHIP_FLASH_DATA_ALIGN_SIZE - 1)) == 0)
        {
            /* The address is 4-byte aligned here */
            next_data_offset = (current_data_offset + ALTERA_ONCHIP_FLASH_DATA_ALIGN_SIZE) & ~(ALTERA_ONCHIP_FLASH_DATA_ALIGN_SIZE - 1);
  105ac8:	3823883a 	mov	r17,r7
  105acc:	00000f06 	br	105b0c <alt_onchip_flash_write_block+0x124>
        } else {
            /* Calculate how many padding bytes need to be added before the start of a data offset */
            int padding = current_data_offset & (ALTERA_ONCHIP_FLASH_DATA_ALIGN_SIZE - 1);

            /* Calculate new 4-byte aligned data offset */
            current_data_offset = current_data_offset - padding;
  105ad0:	8907c83a 	sub	r3,r17,r4
            next_data_offset = (current_data_offset + ALTERA_ONCHIP_FLASH_DATA_ALIGN_SIZE) & ~(ALTERA_ONCHIP_FLASH_DATA_ALIGN_SIZE - 1);
  105ad4:	1c400104 	addi	r17,r3,4
  105ad8:	8da2703a 	and	r17,r17,r22
            length_of_current_write = MIN(length + padding, next_data_offset - current_data_offset);
            /* Prepare the 4 bytes chunk of data to be written */
            memcpy((void *)(((int)&chunk_of_data) + (int)padding), &((alt_u8*)data)[buffer_offset], length_of_current_write - padding);
  105adc:	9105883a 	add	r2,r18,r4
  105ae0:	88e9c83a 	sub	r20,r17,r3
  105ae4:	1500010e 	bge	r2,r20,105aec <alt_onchip_flash_write_block+0x104>
  105ae8:	1029883a 	mov	r20,r2
  105aec:	a129c83a 	sub	r20,r20,r4
  105af0:	a00d883a 	mov	r6,r20
  105af4:	d909883a 	add	r4,sp,r4
  105af8:	d8c00115 	stw	r3,4(sp)
  105afc:	0105f040 	call	105f04 <memcpy>
            buffer_offset += length_of_current_write - padding;
            length -= length_of_current_write - padding;
  105b00:	d8c00117 	ldw	r3,4(sp)
            current_data_offset = current_data_offset - padding;
            next_data_offset = (current_data_offset + ALTERA_ONCHIP_FLASH_DATA_ALIGN_SIZE) & ~(ALTERA_ONCHIP_FLASH_DATA_ALIGN_SIZE - 1);
            length_of_current_write = MIN(length + padding, next_data_offset - current_data_offset);
            /* Prepare the 4 bytes chunk of data to be written */
            memcpy((void *)(((int)&chunk_of_data) + (int)padding), &((alt_u8*)data)[buffer_offset], length_of_current_write - padding);
            buffer_offset += length_of_current_write - padding;
  105b04:	ad2b883a 	add	r21,r21,r20
            length -= length_of_current_write - padding;
  105b08:	9525c83a 	sub	r18,r18,r20
        }

        /* Writing to flash via IO 32 bits at a time */
        IOWR_32DIRECT(flash->dev.base_addr, current_data_offset, chunk_of_data);
  105b0c:	98800a17 	ldw	r2,40(r19)
  105b10:	10c7883a 	add	r3,r2,r3
  105b14:	d8800017 	ldw	r2,0(sp)
  105b18:	18800035 	stwio	r2,0(r3)

        /* Wait until flash controller idle */
        ret_code = alt_onchip_flash_poll_for_status_to_go_idle(flash);
  105b1c:	9809883a 	mov	r4,r19
  105b20:	01057f00 	call	1057f0 <alt_onchip_flash_poll_for_status_to_go_idle>
        if (ret_code != 0)
  105b24:	1000031e 	bne	r2,zero,105b34 <alt_onchip_flash_write_block+0x14c>
        {
            break;
        }

        /* Wait until flash controller indicate write passed */
        ret_code = alt_onchip_flash_poll_for_status_write_passed(flash);
  105b28:	9809883a 	mov	r4,r19
  105b2c:	010598c0 	call	10598c <alt_onchip_flash_poll_for_status_write_passed>
        if (ret_code != 0)
  105b30:	103fd326 	beq	r2,zero,105a80 <_gp+0xffff7830>
        {
            break;
        }

        /* Wait until flash controller indicate write passed */
        ret_code = alt_onchip_flash_poll_for_status_write_passed(flash);
  105b34:	1021883a 	mov	r16,r2
        /* Prepare to write next 4 bytes */
        current_data_offset = next_data_offset;
    }

    /* Disable write and erase operation */
    ALTERA_ONCHIP_FLASH_DISABLE_WRITE_AND_ERASE_OPERATION(flash->csr_base);
  105b38:	98802f17 	ldw	r2,188(r19)
  105b3c:	10800104 	addi	r2,r2,4
  105b40:	11000037 	ldwio	r4,0(r2)
  105b44:	00c40034 	movhi	r3,4096
  105b48:	18ffffc4 	addi	r3,r3,-1
  105b4c:	20c6b03a 	or	r3,r4,r3
  105b50:	10c00035 	stwio	r3,0(r2)
  105b54:	00000406 	br	105b68 <alt_onchip_flash_write_block+0x180>
    if (
        (block_offset >= flash->dev.length) ||
        (data_offset >= flash->dev.length) ||
        (length > (flash->dev.length - data_offset))
    ) {
        return -EFAULT;
  105b58:	00bffc84 	movi	r2,-14
  105b5c:	00000306 	br	105b6c <alt_onchip_flash_write_block+0x184>
    }

    /* Make sure IP support support write and erase operation */
    if ((flash->csr_base == NULL) || (flash->is_read_only != 0)) {
        return -ENODEV;
  105b60:	00bffb44 	movi	r2,-19
  105b64:	00000106 	br	105b6c <alt_onchip_flash_write_block+0x184>
  105b68:	8005883a 	mov	r2,r16

    /* Disable write and erase operation */
    ALTERA_ONCHIP_FLASH_DISABLE_WRITE_AND_ERASE_OPERATION(flash->csr_base);

    return ret_code;
}
  105b6c:	dfc00b17 	ldw	ra,44(sp)
  105b70:	df000a17 	ldw	fp,40(sp)
  105b74:	ddc00917 	ldw	r23,36(sp)
  105b78:	dd800817 	ldw	r22,32(sp)
  105b7c:	dd400717 	ldw	r21,28(sp)
  105b80:	dd000617 	ldw	r20,24(sp)
  105b84:	dcc00517 	ldw	r19,20(sp)
  105b88:	dc800417 	ldw	r18,16(sp)
  105b8c:	dc400317 	ldw	r17,12(sp)
  105b90:	dc000217 	ldw	r16,8(sp)
  105b94:	dec00c04 	addi	sp,sp,48
  105b98:	f800283a 	ret

00105b9c <alt_busy_sleep>:
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
  105b9c:	01440034 	movhi	r5,4096
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
  105ba0:	defffe04 	addi	sp,sp,-8
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
  105ba4:	297fffc4 	addi	r5,r5,-1
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
  105ba8:	dc000015 	stw	r16,0(sp)
  105bac:	dfc00115 	stw	ra,4(sp)
  105bb0:	2021883a 	mov	r16,r4
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
  105bb4:	01045640 	call	104564 <__udivsi3>
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  105bb8:	10000e26 	beq	r2,zero,105bf4 <alt_busy_sleep+0x58>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
  105bbc:	01600034 	movhi	r5,32768
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
  105bc0:	013c0034 	movhi	r4,61440
  105bc4:	0007883a 	mov	r3,zero
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
  105bc8:	297fffc4 	addi	r5,r5,-1
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
  105bcc:	21000044 	addi	r4,r4,1
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
  105bd0:	297fffc4 	addi	r5,r5,-1
  105bd4:	283ffe1e 	bne	r5,zero,105bd0 <_gp+0xffff7980>
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
  105bd8:	18c00044 	addi	r3,r3,1
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
  105bdc:	8121883a 	add	r16,r16,r4
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
  105be0:	18bffb16 	blt	r3,r2,105bd0 <_gp+0xffff7980>
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
  105be4:	802090fa 	slli	r16,r16,3
  105be8:	843fffc4 	addi	r16,r16,-1
  105bec:	803ffe1e 	bne	r16,zero,105be8 <_gp+0xffff7998>
  105bf0:	00000306 	br	105c00 <alt_busy_sleep+0x64>
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
  105bf4:	802090fa 	slli	r16,r16,3
  105bf8:	843fffc4 	addi	r16,r16,-1
  105bfc:	043ffe16 	blt	zero,r16,105bf8 <_gp+0xffff79a8>
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
}
  105c00:	0005883a 	mov	r2,zero
  105c04:	dfc00117 	ldw	ra,4(sp)
  105c08:	dc000017 	ldw	r16,0(sp)
  105c0c:	dec00204 	addi	sp,sp,8
  105c10:	f800283a 	ret

00105c14 <alt_dcache_flush>:
 *
 * Any dirty lines in the data cache are written back to memory.
 */

void alt_dcache_flush (void* start, alt_u32 len)
{
  105c14:	f800283a 	ret

00105c18 <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
  105c18:	f800283a 	ret

00105c1c <alt_dev_llist_insert>:
{
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
  105c1c:	20000226 	beq	r4,zero,105c28 <alt_dev_llist_insert+0xc>
  105c20:	20800217 	ldw	r2,8(r4)
  105c24:	1000101e 	bne	r2,zero,105c68 <alt_dev_llist_insert+0x4c>
  105c28:	d0a00717 	ldw	r2,-32740(gp)
  105c2c:	10000926 	beq	r2,zero,105c54 <alt_dev_llist_insert+0x38>
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
  105c30:	deffff04 	addi	sp,sp,-4
  105c34:	dfc00015 	stw	ra,0(sp)
  105c38:	103ee83a 	callr	r2
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
  {
    ALT_ERRNO = EINVAL;
  105c3c:	00c00584 	movi	r3,22
  105c40:	10c00015 	stw	r3,0(r2)
    return -EINVAL;
  105c44:	00bffa84 	movi	r2,-22
   */
  
  alt_llist_insert(list, &dev->llist);

  return 0;  
}
  105c48:	dfc00017 	ldw	ra,0(sp)
  105c4c:	dec00104 	addi	sp,sp,4
  105c50:	f800283a 	ret
  105c54:	d0a09d04 	addi	r2,gp,-32140
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
  {
    ALT_ERRNO = EINVAL;
  105c58:	00c00584 	movi	r3,22
  105c5c:	10c00015 	stw	r3,0(r2)
    return -EINVAL;
  105c60:	00bffa84 	movi	r2,-22
   */
  
  alt_llist_insert(list, &dev->llist);

  return 0;  
}
  105c64:	f800283a 	ret

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
  entry->next     = list->next;
  105c68:	28800017 	ldw	r2,0(r5)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
  105c6c:	21400115 	stw	r5,4(r4)
  entry->next     = list->next;
  105c70:	20800015 	stw	r2,0(r4)

  list->next->previous = entry;
  105c74:	28800017 	ldw	r2,0(r5)
  105c78:	11000115 	stw	r4,4(r2)
  list->next           = entry;
  105c7c:	29000015 	stw	r4,0(r5)
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);

  return 0;  
  105c80:	0005883a 	mov	r2,zero
  105c84:	f800283a 	ret

00105c88 <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
  105c88:	defffb04 	addi	sp,sp,-20
  105c8c:	dcc00315 	stw	r19,12(sp)
  105c90:	dc800215 	stw	r18,8(sp)
  105c94:	dc400115 	stw	r17,4(sp)
  105c98:	dc000015 	stw	r16,0(sp)
  105c9c:	dfc00415 	stw	ra,16(sp)
  105ca0:	2027883a 	mov	r19,r4
  105ca4:	2823883a 	mov	r17,r5
  alt_dev* next = (alt_dev*) llist->next;
  105ca8:	2c000017 	ldw	r16,0(r5)
  alt_32 len;

  len  = strlen(name) + 1;
  105cac:	010473c0 	call	10473c <strlen>
  105cb0:	14800044 	addi	r18,r2,1
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
  105cb4:	84400726 	beq	r16,r17,105cd4 <alt_find_dev+0x4c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
  105cb8:	81000217 	ldw	r4,8(r16)
  105cbc:	900d883a 	mov	r6,r18
  105cc0:	980b883a 	mov	r5,r19
  105cc4:	0105ed40 	call	105ed4 <memcmp>
  105cc8:	10000426 	beq	r2,zero,105cdc <alt_find_dev+0x54>
    {
      /* match found */

      return next;
    }
    next = (alt_dev*) next->llist.next;
  105ccc:	84000017 	ldw	r16,0(r16)
  105cd0:	003ff806 	br	105cb4 <_gp+0xffff7a64>
  }
  
  /* No match found */
  
  return NULL;
  105cd4:	0005883a 	mov	r2,zero
  105cd8:	00000106 	br	105ce0 <alt_find_dev+0x58>
  105cdc:	8005883a 	mov	r2,r16
}
  105ce0:	dfc00417 	ldw	ra,16(sp)
  105ce4:	dcc00317 	ldw	r19,12(sp)
  105ce8:	dc800217 	ldw	r18,8(sp)
  105cec:	dc400117 	ldw	r17,4(sp)
  105cf0:	dc000017 	ldw	r16,0(sp)
  105cf4:	dec00504 	addi	sp,sp,20
  105cf8:	f800283a 	ret

00105cfc <alt_flash_open_dev>:
#include "priv/alt_file.h"

ALT_LLIST_HEAD(alt_flash_dev_list);

alt_flash_fd* alt_flash_open_dev(const char* name)
{
  105cfc:	defffe04 	addi	sp,sp,-8
  alt_flash_dev* dev = (alt_flash_dev*)alt_find_dev(name, &alt_flash_dev_list);
  105d00:	d1600804 	addi	r5,gp,-32736
#include "priv/alt_file.h"

ALT_LLIST_HEAD(alt_flash_dev_list);

alt_flash_fd* alt_flash_open_dev(const char* name)
{
  105d04:	dc000015 	stw	r16,0(sp)
  105d08:	dfc00115 	stw	ra,4(sp)
  105d0c:	2021883a 	mov	r16,r4
  alt_flash_dev* dev = (alt_flash_dev*)alt_find_dev(name, &alt_flash_dev_list);
  105d10:	0105c880 	call	105c88 <alt_find_dev>

  if ((dev) && dev->open)
  105d14:	10000826 	beq	r2,zero,105d38 <alt_flash_open_dev+0x3c>
  105d18:	10c00317 	ldw	r3,12(r2)
  105d1c:	18000726 	beq	r3,zero,105d3c <alt_flash_open_dev+0x40>
  {
    return dev->open(dev, name);
  105d20:	800b883a 	mov	r5,r16
  105d24:	1009883a 	mov	r4,r2
  }

  return dev;
}
  105d28:	dfc00117 	ldw	ra,4(sp)
  105d2c:	dc000017 	ldw	r16,0(sp)
  105d30:	dec00204 	addi	sp,sp,8
{
  alt_flash_dev* dev = (alt_flash_dev*)alt_find_dev(name, &alt_flash_dev_list);

  if ((dev) && dev->open)
  {
    return dev->open(dev, name);
  105d34:	1800683a 	jmp	r3
  105d38:	0005883a 	mov	r2,zero
  }

  return dev;
}
  105d3c:	dfc00117 	ldw	ra,4(sp)
  105d40:	dc000017 	ldw	r16,0(sp)
  105d44:	dec00204 	addi	sp,sp,8
  105d48:	f800283a 	ret

00105d4c <alt_flash_close_dev>:

void alt_flash_close_dev(alt_flash_fd* fd)
{
  if (fd && fd->close)
  105d4c:	20000326 	beq	r4,zero,105d5c <alt_flash_close_dev+0x10>
  105d50:	20800417 	ldw	r2,16(r4)
  105d54:	10000126 	beq	r2,zero,105d5c <alt_flash_close_dev+0x10>
  {
    fd->close(fd);
  105d58:	1000683a 	jmp	r2
  105d5c:	f800283a 	ret

00105d60 <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
  105d60:	f800283a 	ret

00105d64 <alt_ic_isr_register>:
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
  105d64:	0105df01 	jmpi	105df0 <alt_iic_isr_register>

00105d68 <alt_ic_irq_enable>:
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  105d68:	0009303a 	rdctl	r4,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  105d6c:	00bfff84 	movi	r2,-2
  105d70:	2084703a 	and	r2,r4,r2
  105d74:	1001703a 	wrctl	status,r2
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();

  alt_irq_active |= (1 << id);
  105d78:	00c00044 	movi	r3,1
  105d7c:	d0a0a117 	ldw	r2,-32124(gp)
  105d80:	194a983a 	sll	r5,r3,r5
  105d84:	288ab03a 	or	r5,r5,r2
  105d88:	d160a115 	stw	r5,-32124(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
  105d8c:	d0a0a117 	ldw	r2,-32124(gp)
  105d90:	100170fa 	wrctl	ienable,r2
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  105d94:	2001703a 	wrctl	status,r4
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
    return alt_irq_enable(irq);
}
  105d98:	0005883a 	mov	r2,zero
  105d9c:	f800283a 	ret

00105da0 <alt_ic_irq_disable>:
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  105da0:	0009303a 	rdctl	r4,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  105da4:	00bfff84 	movi	r2,-2
  105da8:	2084703a 	and	r2,r4,r2
  105dac:	1001703a 	wrctl	status,r2
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();

  alt_irq_active &= ~(1 << id);
  105db0:	00ffff84 	movi	r3,-2
  105db4:	d0a0a117 	ldw	r2,-32124(gp)
  105db8:	194a183a 	rol	r5,r3,r5
  105dbc:	288a703a 	and	r5,r5,r2
  105dc0:	d160a115 	stw	r5,-32124(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
  105dc4:	d0a0a117 	ldw	r2,-32124(gp)
  105dc8:	100170fa 	wrctl	ienable,r2
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  105dcc:	2001703a 	wrctl	status,r4
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
    return alt_irq_disable(irq);
}
  105dd0:	0005883a 	mov	r2,zero
  105dd4:	f800283a 	ret

00105dd8 <alt_ic_irq_enabled>:
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
  105dd8:	000730fa 	rdctl	r3,ienable

    return (irq_enabled & (1 << irq)) ? 1: 0;
  105ddc:	00800044 	movi	r2,1
  105de0:	1144983a 	sll	r2,r2,r5
  105de4:	10c4703a 	and	r2,r2,r3
}
  105de8:	1004c03a 	cmpne	r2,r2,zero
  105dec:	f800283a 	ret

00105df0 <alt_iic_isr_register>:
{
  int rc = -EINVAL;  
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
  alt_irq_context status;

  if (id < ALT_NIRQ)
  105df0:	00c007c4 	movi	r3,31
  105df4:	19401616 	blt	r3,r5,105e50 <alt_iic_isr_register+0x60>
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
  105df8:	defffe04 	addi	sp,sp,-8
  105dfc:	dfc00115 	stw	ra,4(sp)
  105e00:	dc000015 	stw	r16,0(sp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  105e04:	0021303a 	rdctl	r16,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  105e08:	00ffff84 	movi	r3,-2
  105e0c:	80c6703a 	and	r3,r16,r3
  105e10:	1801703a 	wrctl	status,r3
     * state.
     */

    status = alt_irq_disable_all();

    alt_irq[id].handler = isr;
  105e14:	280490fa 	slli	r2,r5,3
  105e18:	00c00434 	movhi	r3,16
  105e1c:	18d93704 	addi	r3,r3,25820
  105e20:	1885883a 	add	r2,r3,r2
  105e24:	11800015 	stw	r6,0(r2)
    alt_irq[id].context = isr_context;
  105e28:	11c00115 	stw	r7,4(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
  105e2c:	30000226 	beq	r6,zero,105e38 <alt_iic_isr_register+0x48>
  105e30:	0105d680 	call	105d68 <alt_ic_irq_enable>
  105e34:	00000106 	br	105e3c <alt_iic_isr_register+0x4c>
  105e38:	0105da00 	call	105da0 <alt_ic_irq_disable>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  105e3c:	8001703a 	wrctl	status,r16

    alt_irq_enable_all(status);
  }

  return rc; 
}
  105e40:	dfc00117 	ldw	ra,4(sp)
  105e44:	dc000017 	ldw	r16,0(sp)
  105e48:	dec00204 	addi	sp,sp,8
  105e4c:	f800283a 	ret
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
  int rc = -EINVAL;  
  105e50:	00bffa84 	movi	r2,-22
  105e54:	f800283a 	ret

00105e58 <altera_nios2_gen2_irq_init>:
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
    NIOS2_WRITE_IENABLE(0);
  105e58:	000170fa 	wrctl	ienable,zero
  105e5c:	f800283a 	ret

00105e60 <alt_exception_cause_generated_bad_addr>:
 *         0: BADADDR is not valid
 */
int 
alt_exception_cause_generated_bad_addr(alt_exception_cause cause)
{
  switch (cause) {
  105e60:	213ffe84 	addi	r4,r4,-6
  105e64:	008003c4 	movi	r2,15
  105e68:	11001636 	bltu	r2,r4,105ec4 <alt_exception_cause_generated_bad_addr+0x64>
  105e6c:	200890ba 	slli	r4,r4,2
  105e70:	00800434 	movhi	r2,16
  105e74:	1097a104 	addi	r2,r2,24196
  105e78:	2089883a 	add	r4,r4,r2
  105e7c:	20800017 	ldw	r2,0(r4)
  105e80:	1000683a 	jmp	r2
  105e84:	00105ecc 	andi	zero,zero,16763
  105e88:	00105ecc 	andi	zero,zero,16763
  105e8c:	00105ec4 	movi	zero,16763
  105e90:	00105ec4 	movi	zero,16763
  105e94:	00105ec4 	movi	zero,16763
  105e98:	00105ecc 	andi	zero,zero,16763
  105e9c:	00105ec4 	movi	zero,16763
  105ea0:	00105ec4 	movi	zero,16763
  105ea4:	00105ecc 	andi	zero,zero,16763
  105ea8:	00105ecc 	andi	zero,zero,16763
  105eac:	00105ec4 	movi	zero,16763
  105eb0:	00105ecc 	andi	zero,zero,16763
  105eb4:	00105ec4 	movi	zero,16763
  105eb8:	00105ec4 	movi	zero,16763
  105ebc:	00105ec4 	movi	zero,16763
  105ec0:	00105ecc 	andi	zero,zero,16763
  case NIOS2_EXCEPTION_ECC_DATA_ERR:
    return 1;

  case NIOS2_EXCEPTION_TLB_MISS:
  case NIOS2_EXCEPTION_ECC_TLB_ERR:
    return 0;
  105ec4:	0005883a 	mov	r2,zero
  105ec8:	f800283a 	ret
  case NIOS2_EXCEPTION_MISALIGNED_TARGET_PC:
  case NIOS2_EXCEPTION_TLB_READ_PERM_VIOLATION:
  case NIOS2_EXCEPTION_TLB_WRITE_PERM_VIOLATION:
  case NIOS2_EXCEPTION_MPU_DATA_REGION_VIOLATION:
  case NIOS2_EXCEPTION_ECC_DATA_ERR:
    return 1;
  105ecc:	00800044 	movi	r2,1
    return 0;

  default:
    return 0;
  }
}
  105ed0:	f800283a 	ret

00105ed4 <memcmp>:
  105ed4:	218d883a 	add	r6,r4,r6
  105ed8:	21800826 	beq	r4,r6,105efc <memcmp+0x28>
  105edc:	20800003 	ldbu	r2,0(r4)
  105ee0:	28c00003 	ldbu	r3,0(r5)
  105ee4:	10c00226 	beq	r2,r3,105ef0 <memcmp+0x1c>
  105ee8:	10c5c83a 	sub	r2,r2,r3
  105eec:	f800283a 	ret
  105ef0:	21000044 	addi	r4,r4,1
  105ef4:	29400044 	addi	r5,r5,1
  105ef8:	003ff706 	br	105ed8 <_gp+0xffff7c88>
  105efc:	0005883a 	mov	r2,zero
  105f00:	f800283a 	ret

00105f04 <memcpy>:
  105f04:	2005883a 	mov	r2,r4
  105f08:	2007883a 	mov	r3,r4
  105f0c:	218d883a 	add	r6,r4,r6
  105f10:	19800526 	beq	r3,r6,105f28 <memcpy+0x24>
  105f14:	29000003 	ldbu	r4,0(r5)
  105f18:	18c00044 	addi	r3,r3,1
  105f1c:	29400044 	addi	r5,r5,1
  105f20:	193fffc5 	stb	r4,-1(r3)
  105f24:	003ffa06 	br	105f10 <_gp+0xffff7cc0>
  105f28:	f800283a 	ret
